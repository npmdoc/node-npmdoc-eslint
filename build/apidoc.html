<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://eslint.org"

    >eslint (v3.19.0)</a>
</h1>
<h4>An AST-based pattern checker for JavaScript.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint">module eslint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine">
            function <span class="apidocSignatureSpan">eslint.</span>CLIEngine
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.RuleTester">
            function <span class="apidocSignatureSpan">eslint.</span>RuleTester
            <span class="apidocSignatureSpan">(testerConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode">
            function <span class="apidocSignatureSpan">eslint.</span>SourceCode
            <span class="apidocSignatureSpan">(text, ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context">
            function <span class="apidocSignatureSpan">eslint.</span>rule_context
            <span class="apidocSignatureSpan">(ruleId, eslint, severity, options, settings, parserOptions, parserPath, meta, parserServices)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.</span>CLIEngine.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.</span>RuleTester.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.</span>SourceCode.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.</span>ast_utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.</span>linter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.</span>logging</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.</span>rule_context.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.</span>rules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.</span>timing</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.CLIEngine">module eslint.CLIEngine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine.CLIEngine">
            function <span class="apidocSignatureSpan">eslint.</span>CLIEngine
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine.getErrorResults">
            function <span class="apidocSignatureSpan">eslint.CLIEngine.</span>getErrorResults
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine.getFormatter">
            function <span class="apidocSignatureSpan">eslint.CLIEngine.</span>getFormatter
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine.outputFixes">
            function <span class="apidocSignatureSpan">eslint.CLIEngine.</span>outputFixes
            <span class="apidocSignatureSpan">(report)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">eslint.CLIEngine.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.CLIEngine.prototype">module eslint.CLIEngine.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine.prototype.addPlugin">
            function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>addPlugin
            <span class="apidocSignatureSpan">(name, pluginobject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine.prototype.constructor">
            function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine.prototype.executeOnFiles">
            function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>executeOnFiles
            <span class="apidocSignatureSpan">(patterns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine.prototype.executeOnText">
            function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>executeOnText
            <span class="apidocSignatureSpan">(text, filename, warnIgnored)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine.prototype.getConfigForFile">
            function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>getConfigForFile
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine.prototype.getFormatter">
            function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>getFormatter
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine.prototype.isPathIgnored">
            function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>isPathIgnored
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.CLIEngine.prototype.resolveFileGlobPatterns">
            function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>resolveFileGlobPatterns
            <span class="apidocSignatureSpan">(patterns)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.RuleTester">module eslint.RuleTester</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.RuleTester.RuleTester">
            function <span class="apidocSignatureSpan">eslint.</span>RuleTester
            <span class="apidocSignatureSpan">(testerConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.RuleTester.describe">
            function <span class="apidocSignatureSpan">eslint.RuleTester.</span>describe
            <span class="apidocSignatureSpan">(text, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.RuleTester.getDefaultConfig">
            function <span class="apidocSignatureSpan">eslint.RuleTester.</span>getDefaultConfig
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.RuleTester.it">
            function <span class="apidocSignatureSpan">eslint.RuleTester.</span>it
            <span class="apidocSignatureSpan">(text, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.RuleTester.resetDefaultConfig">
            function <span class="apidocSignatureSpan">eslint.RuleTester.</span>resetDefaultConfig
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.RuleTester.setDefaultConfig">
            function <span class="apidocSignatureSpan">eslint.RuleTester.</span>setDefaultConfig
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.RuleTester.prototype">module eslint.RuleTester.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.RuleTester.prototype.defineRule">
            function <span class="apidocSignatureSpan">eslint.RuleTester.prototype.</span>defineRule
            <span class="apidocSignatureSpan">(name, rule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.RuleTester.prototype.run">
            function <span class="apidocSignatureSpan">eslint.RuleTester.prototype.</span>run
            <span class="apidocSignatureSpan">(ruleName, rule, test)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.SourceCode">module eslint.SourceCode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode.SourceCode">
            function <span class="apidocSignatureSpan">eslint.</span>SourceCode
            <span class="apidocSignatureSpan">(text, ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode.splitLines">
            function <span class="apidocSignatureSpan">eslint.SourceCode.</span>splitLines
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.SourceCode.prototype">module eslint.SourceCode.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode.prototype.constructor">
            function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>constructor
            <span class="apidocSignatureSpan">(text, ast)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode.prototype.getAllComments">
            function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getAllComments
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode.prototype.getComments">
            function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getComments
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode.prototype.getIndexFromLoc">
            function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getIndexFromLoc
            <span class="apidocSignatureSpan">(loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode.prototype.getJSDocComment">
            function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getJSDocComment
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode.prototype.getLines">
            function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getLines
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode.prototype.getLocFromIndex">
            function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getLocFromIndex
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode.prototype.getNodeByRangeIndex">
            function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getNodeByRangeIndex
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode.prototype.getText">
            function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getText
            <span class="apidocSignatureSpan">(node, beforeCount, afterCount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.SourceCode.prototype.isSpaceBetweenTokens">
            function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>isSpaceBetweenTokens
            <span class="apidocSignatureSpan">(first, second)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.ast_utils">module eslint.ast_utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.couldBeError">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>couldBeError
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.createGlobalLinebreakMatcher">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>createGlobalLinebreakMatcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.getDirectivePrologue">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getDirectivePrologue
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.getFunctionHeadLoc">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getFunctionHeadLoc
            <span class="apidocSignatureSpan">(node, sourceCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.getFunctionNameWithKind">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getFunctionNameWithKind
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.getLabel">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getLabel
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.getModifyingReferences">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getModifyingReferences
            <span class="apidocSignatureSpan">(references)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.getParenthesisedText">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getParenthesisedText
            <span class="apidocSignatureSpan">(sourceCode, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.getPrecedence">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getPrecedence
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.getStaticPropertyName">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getStaticPropertyName
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.getTrailingStatement">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getTrailingStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.getUpperFunction">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getUpperFunction
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.getVariableByName">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getVariableByName
            <span class="apidocSignatureSpan">(initScope, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isArrayFromMethod">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isArrayFromMethod
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isArrowToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isArrowToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isBreakableStatement">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isBreakableStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isCallee">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isCallee
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isClosingBraceToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isClosingBraceToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isClosingBracketToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isClosingBracketToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isClosingParenToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isClosingParenToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isColonToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isColonToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isCommaToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isCommaToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isCommentToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isCommentToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isDecimalInteger">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isDecimalInteger
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isDefaultThisBinding">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isDefaultThisBinding
            <span class="apidocSignatureSpan">(node, sourceCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isDirectiveComment">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isDirectiveComment
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isES5Constructor">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isES5Constructor
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isEmptyBlock">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isEmptyBlock
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isEmptyFunction">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isEmptyFunction
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isFunction">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isFunction
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isInLoop">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isInLoop
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isKeywordToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isKeywordToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isLoop">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isLoop
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isNotClosingBraceToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotClosingBraceToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isNotClosingBracketToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotClosingBracketToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isNotClosingParenToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotClosingParenToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isNotColonToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotColonToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isNotCommaToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotCommaToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isNotOpeningBraceToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotOpeningBraceToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isNotOpeningBracketToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotOpeningBracketToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isNotOpeningParenToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotOpeningParenToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isNotSemicolonToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotSemicolonToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isNullLiteral">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNullLiteral
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isNullOrUndefined">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNullOrUndefined
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isOpeningBraceToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isOpeningBraceToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isOpeningBracketToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isOpeningBracketToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isOpeningParenToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isOpeningParenToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isParenthesised">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isParenthesised
            <span class="apidocSignatureSpan">(sourceCode, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isSemicolonToken">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isSemicolonToken
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isStringLiteral">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isStringLiteral
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isSurroundedBy">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isSurroundedBy
            <span class="apidocSignatureSpan">(val, character)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.ast_utils.isTokenOnSameLine">
            function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isTokenOnSameLine
            <span class="apidocSignatureSpan">(left, right)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.ast_utils.</span>COMMENTS_IGNORE_PATTERN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.ast_utils.</span>LINEBREAKS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.ast_utils.</span>LINEBREAK_MATCHER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">eslint.ast_utils.</span>STATEMENT_LIST_PARENTS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.linter">module eslint.linter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.defaults">
            function <span class="apidocSignatureSpan">eslint.linter.</span>defaults
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.defineRule">
            function <span class="apidocSignatureSpan">eslint.linter.</span>defineRule
            <span class="apidocSignatureSpan">(ruleId, ruleModule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.defineRules">
            function <span class="apidocSignatureSpan">eslint.linter.</span>defineRules
            <span class="apidocSignatureSpan">(rulesToDefine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getAllComments">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getAllComments
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getAncestors">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getAncestors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getComments">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getComments
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getDeclaredVariables">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getDeclaredVariables
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getFilename">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getFilename
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getFirstToken">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getFirstToken
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getFirstTokens">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getFirstTokens
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getJSDocComment">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getJSDocComment
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getLastToken">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getLastToken
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getLastTokens">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getLastTokens
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getNodeByRangeIndex">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getNodeByRangeIndex
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getRules">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getScope">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getSource">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getSource
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getSourceCode">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getSourceCode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getSourceLines">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getSourceLines
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getTokenAfter">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getTokenAfter
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getTokenBefore">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getTokenBefore
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getTokenByRangeStart">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getTokenByRangeStart
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getTokens">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getTokens
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getTokensAfter">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getTokensAfter
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getTokensBefore">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getTokensBefore
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.getTokensBetween">
            function <span class="apidocSignatureSpan">eslint.linter.</span>getTokensBetween
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.markVariableAsUsed">
            function <span class="apidocSignatureSpan">eslint.linter.</span>markVariableAsUsed
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.report">
            function <span class="apidocSignatureSpan">eslint.linter.</span>report
            <span class="apidocSignatureSpan">(ruleId, severity, node, location, message, opts, fix, meta)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.reset">
            function <span class="apidocSignatureSpan">eslint.linter.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.linter.verify">
            function <span class="apidocSignatureSpan">eslint.linter.</span>verify
            <span class="apidocSignatureSpan">(textOrSourceCode, config, filenameOrOptions, saveState)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">eslint.linter.</span>_maxListeners</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">eslint.linter.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.logging">module eslint.logging</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.logging.error">
            function <span class="apidocSignatureSpan">eslint.logging.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.logging.info">
            function <span class="apidocSignatureSpan">eslint.logging.</span>info
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.options">module eslint.options</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.options.generateHelp">
            function <span class="apidocSignatureSpan">eslint.options.</span>generateHelp
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.options.generateHelpForOption">
            function <span class="apidocSignatureSpan">eslint.options.</span>generateHelpForOption
            <span class="apidocSignatureSpan">(optionName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.options.parse">
            function <span class="apidocSignatureSpan">eslint.options.</span>parse
            <span class="apidocSignatureSpan">(input, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.options.parseArgv">
            function <span class="apidocSignatureSpan">eslint.options.</span>parseArgv
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.rule_context">module eslint.rule_context</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.rule_context">
            function <span class="apidocSignatureSpan">eslint.</span>rule_context
            <span class="apidocSignatureSpan">(ruleId, eslint, severity, options, settings, parserOptions, parserPath, meta, parserServices)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.rule_context.prototype">module eslint.rule_context.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getAllComments">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getAllComments
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getAncestors">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getAncestors
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getComments">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getComments
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getDeclaredVariables">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getDeclaredVariables
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getFilename">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getFilename
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getFirstToken">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getFirstToken
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getFirstTokens">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getFirstTokens
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getJSDocComment">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getJSDocComment
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getLastToken">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getLastToken
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getLastTokens">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getLastTokens
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getNodeByRangeIndex">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getNodeByRangeIndex
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getScope">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getScope
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getSource">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getSource
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getSourceLines">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getSourceLines
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getTokenAfter">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokenAfter
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getTokenBefore">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokenBefore
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getTokenByRangeStart">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokenByRangeStart
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getTokens">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokens
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getTokensAfter">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokensAfter
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getTokensBefore">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokensBefore
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.getTokensBetween">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokensBetween
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rule_context.prototype.markVariableAsUsed">
            function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>markVariableAsUsed
            <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.rules">module eslint.rules</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rules.define">
            function <span class="apidocSignatureSpan">eslint.rules.</span>define
            <span class="apidocSignatureSpan">(ruleId, ruleModule)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rules.get">
            function <span class="apidocSignatureSpan">eslint.rules.</span>get
            <span class="apidocSignatureSpan">(ruleId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rules.getAllLoadedRules">
            function <span class="apidocSignatureSpan">eslint.rules.</span>getAllLoadedRules
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rules.importPlugin">
            function <span class="apidocSignatureSpan">eslint.rules.</span>importPlugin
            <span class="apidocSignatureSpan">(plugin, pluginName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rules.load">
            function <span class="apidocSignatureSpan">eslint.rules.</span>load
            <span class="apidocSignatureSpan">(rulesDir, cwd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rules.testClear">
            function <span class="apidocSignatureSpan">eslint.rules.</span>testClear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.rules.testReset">
            function <span class="apidocSignatureSpan">eslint.rules.</span>testReset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.eslint.timing">module eslint.timing</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">eslint.timing.</span>enabled</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.eslint.timing.time">
            function <span class="apidocSignatureSpan">eslint.timing.</span>time
            <span class="apidocSignatureSpan">(key, fn)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint" id="apidoc.module.eslint">module eslint</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.CLIEngine" id="apidoc.element.eslint.CLIEngine">
        function <span class="apidocSignatureSpan">eslint.</span>CLIEngine
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CLIEngine(options) {

    options = Object.assign(
        Object.create(null),
        defaultOptions,
        { cwd: process.cwd() },
        options
    );

<span class="apidocCodeCommentSpan">    /**
     * Stored options for this instance
     * @type {Object}
     */
</span>    this.options = options;

    const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);

    /**
     * Cache used to avoid operating on files that haven&#x27;t changed since the
     * last successful execution (e.g., file passed linting with no errors and
     * no warnings).
     * @type {Object}
     */
    this._fileCache = fileEntryCache.create(cacheFile);

    // load in additional rules
    if (this.options.rulePaths) {
        const cwd = this.options.cwd;

        this.options.rulePaths.forEach(rulesdir =&#x3e; {
            debug(`Loading rules from ${rulesdir}`);
            rules.load(rulesdir, cwd);
        });
    }

    Object.keys(this.options.rules || {}).forEach(name =&#x3e; {
        validator.validateRuleOptions(name, this.options.rules[name], &#x22;CLI&#x22;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.RuleTester" id="apidoc.element.eslint.RuleTester">
        function <span class="apidocSignatureSpan">eslint.</span>RuleTester
        <span class="apidocSignatureSpan">(testerConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleTester(testerConfig) {

<span class="apidocCodeCommentSpan">    /**
     * The configuration to use for this tester. Combination of the tester
     * configuration and the default configuration.
     * @type {Object}
     */
</span>    this.testerConfig = lodash.merge(

        // we have to clone because merge uses the first argument for recipient
        lodash.cloneDeep(defaultConfig),
        testerConfig
    );

    /**
     * Rule definitions to define before tests.
     * @type {Object}
     */
    this.rules = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.SourceCode" id="apidoc.element.eslint.SourceCode">
        function <span class="apidocSignatureSpan">eslint.</span>SourceCode
        <span class="apidocSignatureSpan">(text, ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceCode(text, ast) {
    validate(ast);

<span class="apidocCodeCommentSpan">    /**
     * The flag to indicate that the source code has Unicode BOM.
     * @type boolean
     */
</span>    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);

    /**
     * The original text source code.
     * BOM was stripped from this text.
     * @type string
     */
    this.text = (this.hasBOM ? text.slice(1) : text);

    /**
     * The parsed AST for the source code.
     * @type ASTNode
     */
    this.ast = ast;

    /**
     * The source code split into lines according to ECMA-262 specification.
     * This is done to avoid each rule needing to do so separately.
     * @type string[]
     */
    this.lines = [];
    this.lineStartIndices = [0];

    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
    let match;

    /*
     * Previously, this was implemented using a regex that
     * matched a sequence of non-linebreak characters followed by a
     * linebreak, then adding the lengths of the matches. However,
     * this caused a catastrophic backtracking issue when the end
     * of a file contained a large number of non-newline characters.
     * To avoid this, the current implementation just matches newlines
     * and uses match.index to get the correct line start indices.
     */
    while ((match = lineEndingPattern.exec(this.text))) {
        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
        this.lineStartIndices.push(match.index + match[0].length);
    }
    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));

    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);

    // create token store methods
    const tokenStore = new TokenStore(ast.tokens, ast.comments);

    for (const methodName of TokenStore.PUBLIC_METHODS) {
        this[methodName] = tokenStore[methodName].bind(tokenStore);
    }

    // don&#x27;t allow modification of this object
    Object.freeze(this);
    Object.freeze(this.lines);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context" id="apidoc.element.eslint.rule_context">
        function <span class="apidocSignatureSpan">eslint.</span>rule_context
        <span class="apidocSignatureSpan">(ruleId, eslint, severity, options, settings, parserOptions, parserPath, meta, parserServices)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class RuleContext {

<span class="apidocCodeCommentSpan">    /**
     * @param {string} ruleId The ID of the rule using this object.
     * @param {eslint} eslint The eslint object.
     * @param {number} severity The configured severity level of the rule.
     * @param {Array} options The configuration information to be added to the rule.
     * @param {Object} settings The configuration settings passed from the config file.
     * @param {Object} parserOptions The parserOptions settings passed from the config file.
     * @param {Object} parserPath The parser setting passed from the config file.
     * @param {Object} meta The metadata of the rule
     * @param {Object} parserServices The parser services for the rule.
     */
</span>    constructor(ruleId, eslint, severity, options, settings, parserOptions, parserPath, meta, parserServices) {

        // public.
        this.id = ruleId;
        this.options = options;
        this.settings = settings;
        this.parserOptions = parserOptions;
        this.parserPath = parserPath;
        this.meta = meta;

        // create a separate copy and freeze it (it&#x27;s not nice to freeze other people&#x27;s objects)
        this.parserServices = Object.freeze(Object.assign({}, parserServices));

        // private.
        this.eslint = eslint;
        this.severity = severity;

        Object.freeze(this);
    }

    /**
     * Passthrough to eslint.getSourceCode().
     * @returns {SourceCode} The SourceCode object for the code.
     */
    getSourceCode() {
        return this.eslint.getSourceCode();
    }

    /**
     * Passthrough to eslint.report() that automatically assigns the rule ID and severity.
     * @param {ASTNode|MessageDescriptor} nodeOrDescriptor The AST node related to the message or a message
     *      descriptor.
     * @param {Object=} location The location of the error.
     * @param {string} message The message to display to the user.
     * @param {Object} opts Optional template data which produces a formatted message
     *     with symbols being replaced by this object&#x27;s values.
     * @returns {void}
     */
    report(nodeOrDescriptor, location, message, opts) {

        // check to see if it&#x27;s a new style call
        if (arguments.length === 1) {
            const descriptor = nodeOrDescriptor;
            let fix = null;

            // if there&#x27;s a fix specified, get it
            if (typeof descriptor.fix === &#x22;function&#x22;) {
                fix = descriptor.fix(ruleFixer);
            }

            this.eslint.report(
                this.id,
                this.severity,
                descriptor.node,
                descriptor.loc || descriptor.node.loc.start,
                descriptor.message,
                descriptor.data,
                fix,
                this.meta
            );

            return;
        }

        // old style call
        this.eslint.report(
            this.id,
            this.severity,
            nodeOrDescriptor,
            location,
            message,
            opts,
            this.meta
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.CLIEngine" id="apidoc.module.eslint.CLIEngine">module eslint.CLIEngine</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.CLIEngine.CLIEngine" id="apidoc.element.eslint.CLIEngine.CLIEngine">
        function <span class="apidocSignatureSpan">eslint.</span>CLIEngine
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CLIEngine(options) {

    options = Object.assign(
        Object.create(null),
        defaultOptions,
        { cwd: process.cwd() },
        options
    );

<span class="apidocCodeCommentSpan">    /**
     * Stored options for this instance
     * @type {Object}
     */
</span>    this.options = options;

    const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);

    /**
     * Cache used to avoid operating on files that haven&#x27;t changed since the
     * last successful execution (e.g., file passed linting with no errors and
     * no warnings).
     * @type {Object}
     */
    this._fileCache = fileEntryCache.create(cacheFile);

    // load in additional rules
    if (this.options.rulePaths) {
        const cwd = this.options.cwd;

        this.options.rulePaths.forEach(rulesdir =&#x3e; {
            debug(`Loading rules from ${rulesdir}`);
            rules.load(rulesdir, cwd);
        });
    }

    Object.keys(this.options.rules || {}).forEach(name =&#x3e; {
        validator.validateRuleOptions(name, this.options.rules[name], &#x22;CLI&#x22;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.CLIEngine.getErrorResults" id="apidoc.element.eslint.CLIEngine.getErrorResults">
        function <span class="apidocSignatureSpan">eslint.CLIEngine.</span>getErrorResults
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getErrorResults = function (results) {
    const filtered = [];

    results.forEach(result =&#x3e; {
        const filteredMessages = result.messages.filter(isErrorMessage);

        if (filteredMessages.length &#x3e; 0) {
            filtered.push(
                Object.assign(result, {
                    messages: filteredMessages,
                    errorCount: filteredMessages.length,
                    warningCount: 0
                })
            );
        }
    });

    return filtered;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.CLIEngine.getFormatter" id="apidoc.element.eslint.CLIEngine.getFormatter">
        function <span class="apidocSignatureSpan">eslint.CLIEngine.</span>getFormatter
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFormatter = function (format) {

    let formatterPath;

    // default is stylish
    format = format || &#x22;stylish&#x22;;

    // only strings are valid formatters
    if (typeof format === &#x22;string&#x22;) {

        // replace \ with / for Windows compatibility
        format = format.replace(/\\/g, &#x22;/&#x22;);

        // if there&#x27;s a slash, then it&#x27;s a file
        if (format.indexOf(&#x22;/&#x22;) &#x3e; -1) {
            const cwd = this.options ? this.options.cwd : process.cwd();

            formatterPath = path.resolve(cwd, format);
        } else {
            formatterPath = `./formatters/${format}`;
        }

        try {
            return require(formatterPath);
        } catch (ex) {
            ex.message = `There was a problem loading formatter: ${formatterPath}\nError: ${ex.message}`;
            throw ex;
        }

    } else {
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.CLIEngine.outputFixes" id="apidoc.element.eslint.CLIEngine.outputFixes">
        function <span class="apidocSignatureSpan">eslint.CLIEngine.</span>outputFixes
        <span class="apidocSignatureSpan">(report)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputFixes = function (report) {
    report.results.filter(result =&#x3e; result.hasOwnProperty(&#x22;output&#x22;)).forEach(result =&#x3e; {
        fs.writeFileSync(result.filePath, result.output);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.CLIEngine.prototype" id="apidoc.module.eslint.CLIEngine.prototype">module eslint.CLIEngine.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.CLIEngine.prototype.addPlugin" id="apidoc.element.eslint.CLIEngine.prototype.addPlugin">
        function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>addPlugin
        <span class="apidocSignatureSpan">(name, pluginobject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addPlugin(name, pluginobject) {
    Plugins.define(name, pluginobject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.CLIEngine.prototype.constructor" id="apidoc.element.eslint.CLIEngine.prototype.constructor">
        function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CLIEngine(options) {

    options = Object.assign(
        Object.create(null),
        defaultOptions,
        { cwd: process.cwd() },
        options
    );

<span class="apidocCodeCommentSpan">    /**
     * Stored options for this instance
     * @type {Object}
     */
</span>    this.options = options;

    const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);

    /**
     * Cache used to avoid operating on files that haven&#x27;t changed since the
     * last successful execution (e.g., file passed linting with no errors and
     * no warnings).
     * @type {Object}
     */
    this._fileCache = fileEntryCache.create(cacheFile);

    // load in additional rules
    if (this.options.rulePaths) {
        const cwd = this.options.cwd;

        this.options.rulePaths.forEach(rulesdir =&#x3e; {
            debug(`Loading rules from ${rulesdir}`);
            rules.load(rulesdir, cwd);
        });
    }

    Object.keys(this.options.rules || {}).forEach(name =&#x3e; {
        validator.validateRuleOptions(name, this.options.rules[name], &#x22;CLI&#x22;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.CLIEngine.prototype.executeOnFiles" id="apidoc.element.eslint.CLIEngine.prototype.executeOnFiles">
        function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>executeOnFiles
        <span class="apidocSignatureSpan">(patterns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">executeOnFiles(patterns) {
    const results = [],
        options = this.options,
        fileCache = this._fileCache,
        configHelper = new Config(options);
    let prevConfig; // the previous configuration used

<span class="apidocCodeCommentSpan">    /**
     * Calculates the hash of the config file used to validate a given file
     * @param  {string} filename The path of the file to retrieve a config object for to calculate the hash
     * @returns {string}         the hash of the config
     */
</span>    function hashOfConfigFor(filename) {
        const config = configHelper.getConfig(filename);

        if (!prevConfig) {
            prevConfig = {};
        }

        // reuse the previously hashed config if the config hasn&#x27;t changed
        if (prevConfig.config !== config) {

            /*
             * config changed so we need to calculate the hash of the config
             * and the hash of the plugins being used
             */
            prevConfig.config = config;

            const eslintVersion = pkg.version;

            prevConfig.hash = hash(`${eslintVersion}_${stringify(config)}`);
        }

        return prevConfig.hash;
    }

    /**
     * Executes the linter on a file defined by the `filename`. Skips
     * unsupported file extensions and any files that are already linted.
     * @param {string} filename The resolved filename of the file to be linted
     * @param {boolean} warnIgnored always warn when a file is ignored
     * @returns {void}
     */
    function executeOnFile(filename, warnIgnored) {
        let hashOfConfig,
            descriptor;

        if (warnIgnored) {
            results.push(createIgnoreResult(filename, options.cwd));
            return;
        }

        if (options.cache) {

            /*
             * get the descriptor for this file
             * with the metadata and the flag that determines if
             * the file has changed
             */
            descriptor = fileCache.getFileDescriptor(filename);
            const meta = descriptor.meta || {};

            hashOfConfig = hashOfConfigFor(filename);

            const changed = descriptor.changed || meta.hashOfConfig !== hashOfConfig;

            if (!changed) {
                debug(`Skipping file since hasn&#x27;t changed: ${filename}`);

                /*
                 * Add the the cached results (always will be 0 error and
                 * 0 warnings). We should not cache results for files that
                 * failed, in order to guarantee that next execution will
                 * process those files as well.
                 */
                results.push(descriptor.meta.results);

                // move to the next file
                return;
            }
        } else {
            fileCache.destroy();
        }

        debug(`Processing ${filename}`);

        const res = processFile(filename, configHelper, options);

        if (options.cache) {

            /*
             * if a file contains errors or warnings we don&#x27;t want to
             * store the file in the cache so we can guarantee that
             * next execution will also operate on this file
             */
            if (res.errorCount &#x3e; 0 || res.warningCount &#x3e; 0) {
                debug(`File has problems, skipping it: ${filename}`);

                // remove the entry from the cache
                fileCache.removeEntry(filename);
            } else {

                /*
                 * since the file passed we store the result here
                 * TODO: check this as we might not need to store the
                 * successful runs as it will always should be 0 errors and
                 * 0 warnings.
                 */
                descriptor.meta.hashOfConfig = hashOfConfig;
                descriptor.meta.results = res;
            }
        }

        results.push(res);
    }

    const startTime = Date.now();



    patterns = this.resolveFileGlobPatterns(patterns);
    const fileList = globUtil.listFilesToProcess(patterns, options);

    fileList.forEach(fileInfo =&#x3e; {
        executeOnFile(fileInfo.filename, fileInfo ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.CLIEngine.prototype.executeOnText" id="apidoc.element.eslint.CLIEngine.prototype.executeOnText">
        function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>executeOnText
        <span class="apidocSignatureSpan">(text, filename, warnIgnored)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">executeOnText(text, filename, warnIgnored) {

    const results = [],
        options = this.options,
        configHelper = new Config(options),
        ignoredPaths = new IgnoredPaths(options);

    // resolve filename based on options.cwd (for reporting, ignoredPaths also resolves)
    if (filename &#x26;&#x26; !path.isAbsolute(filename)) {
        filename = path.resolve(options.cwd, filename);
    }

    if (filename &#x26;&#x26; ignoredPaths.contains(filename)) {
        if (warnIgnored) {
            results.push(createIgnoreResult(filename, options.cwd));
        }
    } else {
        results.push(processText(text, configHelper, filename, options.fix, options.allowInlineConfig));
    }

    const stats = calculateStatsPerRun(results);

    return {
        results,
        errorCount: stats.errorCount,
        warningCount: stats.warningCount
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.CLIEngine.prototype.getConfigForFile" id="apidoc.element.eslint.CLIEngine.prototype.getConfigForFile">
        function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>getConfigForFile
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfigForFile(filePath) {
    const configHelper = new Config(this.options);

    return configHelper.getConfig(filePath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.CLIEngine.prototype.getFormatter" id="apidoc.element.eslint.CLIEngine.prototype.getFormatter">
        function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>getFormatter
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFormatter = function (format) {

    let formatterPath;

    // default is stylish
    format = format || &#x22;stylish&#x22;;

    // only strings are valid formatters
    if (typeof format === &#x22;string&#x22;) {

        // replace \ with / for Windows compatibility
        format = format.replace(/\\/g, &#x22;/&#x22;);

        // if there&#x27;s a slash, then it&#x27;s a file
        if (format.indexOf(&#x22;/&#x22;) &#x3e; -1) {
            const cwd = this.options ? this.options.cwd : process.cwd();

            formatterPath = path.resolve(cwd, format);
        } else {
            formatterPath = `./formatters/${format}`;
        }

        try {
            return require(formatterPath);
        } catch (ex) {
            ex.message = `There was a problem loading formatter: ${formatterPath}\nError: ${ex.message}`;
            throw ex;
        }

    } else {
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.CLIEngine.prototype.isPathIgnored" id="apidoc.element.eslint.CLIEngine.prototype.isPathIgnored">
        function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>isPathIgnored
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPathIgnored(filePath) {
    const resolvedPath = path.resolve(this.options.cwd, filePath);
    const ignoredPaths = new IgnoredPaths(this.options);

    return ignoredPaths.contains(resolvedPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.CLIEngine.prototype.resolveFileGlobPatterns" id="apidoc.element.eslint.CLIEngine.prototype.resolveFileGlobPatterns">
        function <span class="apidocSignatureSpan">eslint.CLIEngine.prototype.</span>resolveFileGlobPatterns
        <span class="apidocSignatureSpan">(patterns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveFileGlobPatterns(patterns) {
    return globUtil.resolveFileGlobPatterns(patterns, this.options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.RuleTester" id="apidoc.module.eslint.RuleTester">module eslint.RuleTester</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.RuleTester.RuleTester" id="apidoc.element.eslint.RuleTester.RuleTester">
        function <span class="apidocSignatureSpan">eslint.</span>RuleTester
        <span class="apidocSignatureSpan">(testerConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RuleTester(testerConfig) {

<span class="apidocCodeCommentSpan">    /**
     * The configuration to use for this tester. Combination of the tester
     * configuration and the default configuration.
     * @type {Object}
     */
</span>    this.testerConfig = lodash.merge(

        // we have to clone because merge uses the first argument for recipient
        lodash.cloneDeep(defaultConfig),
        testerConfig
    );

    /**
     * Rule definitions to define before tests.
     * @type {Object}
     */
    this.rules = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.RuleTester.describe" id="apidoc.element.eslint.RuleTester.describe">
        function <span class="apidocSignatureSpan">eslint.RuleTester.</span>describe
        <span class="apidocSignatureSpan">(text, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultHandler(text, method) {
    return method.apply(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.RuleTester.getDefaultConfig" id="apidoc.element.eslint.RuleTester.getDefaultConfig">
        function <span class="apidocSignatureSpan">eslint.RuleTester.</span>getDefaultConfig
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefaultConfig = function () {
    return defaultConfig;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.RuleTester.it" id="apidoc.element.eslint.RuleTester.it">
        function <span class="apidocSignatureSpan">eslint.RuleTester.</span>it
        <span class="apidocSignatureSpan">(text, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultHandler(text, method) {
    return method.apply(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.RuleTester.resetDefaultConfig" id="apidoc.element.eslint.RuleTester.resetDefaultConfig">
        function <span class="apidocSignatureSpan">eslint.RuleTester.</span>resetDefaultConfig
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetDefaultConfig = function () {
    defaultConfig = lodash.cloneDeep(testerDefaultConfig);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.RuleTester.setDefaultConfig" id="apidoc.element.eslint.RuleTester.setDefaultConfig">
        function <span class="apidocSignatureSpan">eslint.RuleTester.</span>setDefaultConfig
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDefaultConfig = function (config) {
    if (typeof config !== &#x22;object&#x22;) {
        throw new Error(&#x22;RuleTester.setDefaultConfig: config must be an object&#x22;);
    }
    defaultConfig = config;

    // Make sure the rules object exists since it is assumed to exist later
    defaultConfig.rules = defaultConfig.rules || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.RuleTester.prototype" id="apidoc.module.eslint.RuleTester.prototype">module eslint.RuleTester.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.RuleTester.prototype.defineRule" id="apidoc.element.eslint.RuleTester.prototype.defineRule">
        function <span class="apidocSignatureSpan">eslint.RuleTester.prototype.</span>defineRule
        <span class="apidocSignatureSpan">(name, rule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineRule(name, rule) {
    this.rules[name] = rule;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.RuleTester.prototype.run" id="apidoc.element.eslint.RuleTester.prototype.run">
        function <span class="apidocSignatureSpan">eslint.RuleTester.prototype.</span>run
        <span class="apidocSignatureSpan">(ruleName, rule, test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run(ruleName, rule, test) {

    const testerConfig = this.testerConfig,
        requiredScenarios = [&#x22;valid&#x22;, &#x22;invalid&#x22;],
        scenarioErrors = [],
        result = {};

    if (lodash.isNil(test) || typeof test !== &#x22;object&#x22;) {
        throw new Error(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);
    }

    requiredScenarios.forEach(scenarioType =&#x3e; {
        if (lodash.isNil(test[scenarioType])) {
            scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);
        }
    });

    if (scenarioErrors.length &#x3e; 0) {
        throw new Error([
            `Test Scenarios for rule ${ruleName} is invalid:`
        ].concat(scenarioErrors).join(&#x22;\n&#x22;));
    }

<span class="apidocCodeCommentSpan">    /* eslint-disable no-shadow */
</span>
    /**
     * Run the rule for the given item
     * @param {string} ruleName name of the rule
     * @param {string|Object} item Item to run the rule against
     * @returns {Object} Eslint run result
     * @private
     */
    function runRuleForItem(ruleName, item) {
        let config = lodash.cloneDeep(testerConfig),
            code, filename, beforeAST, afterAST;

        if (typeof item === &#x22;string&#x22;) {
            code = item;
        } else {
            code = item.code;

            // Assumes everything on the item is a config except for the
            // parameters used by this tester
            const itemConfig = lodash.omit(item, RuleTesterParameters);

            // Create the config object from the tester config and this item
            // specific configurations.
            config = lodash.merge(
                config,
                itemConfig
            );
        }

        if (item.filename) {
            filename = item.filename;
        }

        if (item.options) {
            const options = item.options.concat();

            options.unshift(1);
            config.rules[ruleName] = options;
        } else {
            config.rules[ruleName] = 1;
        }

        eslint.defineRule(ruleName, rule);

        const schema = validator.getRuleOptionsSchema(ruleName);

        if (schema) {
            validateSchema(schema);

            if (validateSchema.errors) {
                throw new Error([
                    `Schema for rule ${ruleName} is invalid:`
                ].concat(validateSchema.errors.map(error =&#x3e; `\t${error.field}: ${error.message}`)).join(&#x22;\n&#x22;));
            }
        }

        validator.validate(config, &#x22;rule-tester&#x22;);

        /*
         * Setup AST getters.
         * The goal is to check whether or not AST was modified when
         * running the rule under test.
         */
        eslint.reset();

        eslint.on(&#x22;Program&#x22;, node =&#x3e; {
            beforeAST = cloneDeeplyExcludesParent(node);
        });

        eslint.on(&#x22;Program:exit&#x22;, node =&#x3e; {
            afterAST = node;
        });

        // Freezes rule-context properties.
        const originalGet = rules.get;

        try {
            rules.get = function(ruleId) {
                const rule = originalGet(ruleId);

                if (typeof rule === &#x22;function&#x22;) {
                    return function(context) {
                        Object.freeze(context);
                        freezeDeeply(context.options);
                        freezeDeeply(context.settings);
                        freezeDeeply(context.parserOptions);

                        return rule(context);
                    };
                }
                return {
                    meta: rule.meta,
                    create(context) {
                        Object.freeze(context);
                        freezeDeeply(context.options);
                        freezeDeeply(context.settings);
                        freezeDeeply(context.parserOptions);

                        return rule.create(context);
                    }
                };

            };

            return {
                messages: eslint.verify(code, config, filename, true),
                beforeAST,
                afterAST: cloneDeeplyExcludesParent(afterAST)
            };
        } finally { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.SourceCode" id="apidoc.module.eslint.SourceCode">module eslint.SourceCode</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.SourceCode.SourceCode" id="apidoc.element.eslint.SourceCode.SourceCode">
        function <span class="apidocSignatureSpan">eslint.</span>SourceCode
        <span class="apidocSignatureSpan">(text, ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceCode(text, ast) {
    validate(ast);

<span class="apidocCodeCommentSpan">    /**
     * The flag to indicate that the source code has Unicode BOM.
     * @type boolean
     */
</span>    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);

    /**
     * The original text source code.
     * BOM was stripped from this text.
     * @type string
     */
    this.text = (this.hasBOM ? text.slice(1) : text);

    /**
     * The parsed AST for the source code.
     * @type ASTNode
     */
    this.ast = ast;

    /**
     * The source code split into lines according to ECMA-262 specification.
     * This is done to avoid each rule needing to do so separately.
     * @type string[]
     */
    this.lines = [];
    this.lineStartIndices = [0];

    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
    let match;

    /*
     * Previously, this was implemented using a regex that
     * matched a sequence of non-linebreak characters followed by a
     * linebreak, then adding the lengths of the matches. However,
     * this caused a catastrophic backtracking issue when the end
     * of a file contained a large number of non-newline characters.
     * To avoid this, the current implementation just matches newlines
     * and uses match.index to get the correct line start indices.
     */
    while ((match = lineEndingPattern.exec(this.text))) {
        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
        this.lineStartIndices.push(match.index + match[0].length);
    }
    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));

    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);

    // create token store methods
    const tokenStore = new TokenStore(ast.tokens, ast.comments);

    for (const methodName of TokenStore.PUBLIC_METHODS) {
        this[methodName] = tokenStore[methodName].bind(tokenStore);
    }

    // don&#x27;t allow modification of this object
    Object.freeze(this);
    Object.freeze(this.lines);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.SourceCode.splitLines" id="apidoc.element.eslint.SourceCode.splitLines">
        function <span class="apidocSignatureSpan">eslint.SourceCode.</span>splitLines
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splitLines = function (text) {
    return text.split(astUtils.createGlobalLinebreakMatcher());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.SourceCode.prototype" id="apidoc.module.eslint.SourceCode.prototype">module eslint.SourceCode.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.SourceCode.prototype.constructor" id="apidoc.element.eslint.SourceCode.prototype.constructor">
        function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>constructor
        <span class="apidocSignatureSpan">(text, ast)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceCode(text, ast) {
    validate(ast);

<span class="apidocCodeCommentSpan">    /**
     * The flag to indicate that the source code has Unicode BOM.
     * @type boolean
     */
</span>    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);

    /**
     * The original text source code.
     * BOM was stripped from this text.
     * @type string
     */
    this.text = (this.hasBOM ? text.slice(1) : text);

    /**
     * The parsed AST for the source code.
     * @type ASTNode
     */
    this.ast = ast;

    /**
     * The source code split into lines according to ECMA-262 specification.
     * This is done to avoid each rule needing to do so separately.
     * @type string[]
     */
    this.lines = [];
    this.lineStartIndices = [0];

    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
    let match;

    /*
     * Previously, this was implemented using a regex that
     * matched a sequence of non-linebreak characters followed by a
     * linebreak, then adding the lengths of the matches. However,
     * this caused a catastrophic backtracking issue when the end
     * of a file contained a large number of non-newline characters.
     * To avoid this, the current implementation just matches newlines
     * and uses match.index to get the correct line start indices.
     */
    while ((match = lineEndingPattern.exec(this.text))) {
        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
        this.lineStartIndices.push(match.index + match[0].length);
    }
    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));

    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);

    // create token store methods
    const tokenStore = new TokenStore(ast.tokens, ast.comments);

    for (const methodName of TokenStore.PUBLIC_METHODS) {
        this[methodName] = tokenStore[methodName].bind(tokenStore);
    }

    // don&#x27;t allow modification of this object
    Object.freeze(this);
    Object.freeze(this.lines);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.SourceCode.prototype.getAllComments" id="apidoc.element.eslint.SourceCode.prototype.getAllComments">
        function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getAllComments
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllComments() {
    return this.ast.comments;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.SourceCode.prototype.getComments" id="apidoc.element.eslint.SourceCode.prototype.getComments">
        function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getComments
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComments(node) {

    let leadingComments = node.leadingComments || [];
    const trailingComments = node.trailingComments || [];

<span class="apidocCodeCommentSpan">    /*
     * espree adds a &#x22;comments&#x22; array on Program nodes rather than
     * leadingComments/trailingComments. Comments are only left in the
     * Program node comments array if there is no executable code.
     */
</span>    if (node.type === &#x22;Program&#x22;) {
        if (node.body.length === 0) {
            leadingComments = node.comments;
        }
    }

    return {
        leading: leadingComments,
        trailing: trailingComments
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       return true;
   }

   // Checks `@this` in its leading comments for callbacks,
   // because callbacks don&#x27;t have its JSDoc comment.
   // e.g.
   //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });
   return sourceCode.<span class="apidocCodeKeywordSpan">getComments</span>(node).leading.some(comment =&#x3e; thisTagPattern.test
(comment.value));
}

/**
* Determines if a node is surrounded by parentheses.
* @param {SourceCode} sourceCode The ESLint source code object
* @param {ASTNode} node The node to be checked.
* @returns {boolean} True if the node is parenthesised.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.SourceCode.prototype.getIndexFromLoc" id="apidoc.element.eslint.SourceCode.prototype.getIndexFromLoc">
        function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getIndexFromLoc
        <span class="apidocSignatureSpan">(loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIndexFromLoc(loc) {
    if (typeof loc !== &#x22;object&#x22; || typeof loc.line !== &#x22;number&#x22; || typeof loc.column !== &#x22;number&#x22;) {
        throw new TypeError(&#x22;Expected `loc` to be an object with numeric `line` and `column` properties.&#x22;);
    }

    if (loc.line &#x3c;= 0) {
        throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);
    }

    if (loc.line &#x3e; this.lineStartIndices.length) {
        throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines
 present).`);
    }

    const lineStartIndex = this.lineStartIndices[loc.line - 1];
    const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];
    const positionIndex = lineStartIndex + loc.column;

<span class="apidocCodeCommentSpan">    /*
     * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of
     * the given line, provided that the line number is valid element of this.lines. Since the
     * last element of this.lines is an empty string for files with trailing newlines, add a
     * special case where getting the index for the first location after the end of the file
     * will return the length of the file, rather than throwing an error. This allows rules to
     * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.
     */
</span>    if (
        loc.line === this.lineStartIndices.length &#x26;&#x26; positionIndex &#x3e; lineEndIndex ||
        loc.line &#x3c; this.lineStartIndices.length &#x26;&#x26; positionIndex &#x3e;= lineEndIndex
    ) {
        throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${
lineEndIndex - lineStartIndex}).`);
    }

    return positionIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.SourceCode.prototype.getJSDocComment" id="apidoc.element.eslint.SourceCode.prototype.getJSDocComment">
        function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getJSDocComment
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJSDocComment(node) {

    let parent = node.parent;

    switch (node.type) {
        case &#x22;ClassDeclaration&#x22;:
        case &#x22;FunctionDeclaration&#x22;:
            if (looksLikeExport(parent)) {
                return findJSDocComment(parent.leadingComments, parent.loc.start.line);
            }
            return findJSDocComment(node.leadingComments, node.loc.start.line);

        case &#x22;ClassExpression&#x22;:
            return findJSDocComment(parent.parent.leadingComments, parent.parent.loc.start.line);

        case &#x22;ArrowFunctionExpression&#x22;:
        case &#x22;FunctionExpression&#x22;:

            if (parent.type !== &#x22;CallExpression&#x22; &#x26;&#x26; parent.type !== &#x22;NewExpression&#x22;) {
                while (parent &#x26;&#x26; !parent.leadingComments &#x26;&#x26; !/Function/.test(parent.type) &#x26;&#x26; parent.type !== &#x22;MethodDefinition&#x22; &#x26;&#x26;
parent.type !== &#x22;Property&#x22;) {
                    parent = parent.parent;
                }

                return parent &#x26;&#x26; (parent.type !== &#x22;FunctionDeclaration&#x22;) ? findJSDocComment(parent.leadingComments, parent.loc.start
.line) : null;
            } else if (node.leadingComments) {
                return findJSDocComment(node.leadingComments, node.loc.start.line);
            }

        // falls through

        default:
            return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Checks whether or not a node has a `@this` tag in its comments.
 * @param {ASTNode} node - A node to check.
 * @param {SourceCode} sourceCode - A SourceCode instance to get comments.
 * @returns {boolean} Whether or not the node has a `@this` tag in its comments.
 */
function hasJSDocThisTag(node, sourceCode) {
const jsdocComment = sourceCode.<span class="apidocCodeKeywordSpan">getJSDocComment</span>(node);

if (jsdocComment &#x26;&#x26; thisTagPattern.test(jsdocComment.value)) {
    return true;
}

// Checks `@this` in its leading comments for callbacks,
// because callbacks don&#x27;t have its JSDoc comment.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.SourceCode.prototype.getLines" id="apidoc.element.eslint.SourceCode.prototype.getLines">
        function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getLines
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLines() {
    return this.lines;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.SourceCode.prototype.getLocFromIndex" id="apidoc.element.eslint.SourceCode.prototype.getLocFromIndex">
        function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getLocFromIndex
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLocFromIndex(index) {
    if (typeof index !== &#x22;number&#x22;) {
        throw new TypeError(&#x22;Expected `index` to be a number.&#x22;);
    }

    if (index &#x3c; 0 || index &#x3e; this.text.length) {
        throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);
    }

<span class="apidocCodeCommentSpan">    /*
     * For an argument of this.text.length, return the location one &#x22;spot&#x22; past the last character
     * of the file. If the last character is a linebreak, the location will be column 0 of the next
     * line; otherwise, the location will be in the next column on the same line.
     *
     * See getIndexFromLoc for the motivation for this special case.
     */
</span>    if (index === this.text.length) {
        return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };
    }

    /*
     * To figure out which line rangeIndex is on, determine the last index at which rangeIndex could
     * be inserted into lineIndices to keep the list sorted.
     */
    const lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);

    return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.SourceCode.prototype.getNodeByRangeIndex" id="apidoc.element.eslint.SourceCode.prototype.getNodeByRangeIndex">
        function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getNodeByRangeIndex
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodeByRangeIndex(index) {
    let result = null,
        resultParent = null;
    const traverser = new Traverser();

    traverser.traverse(this.ast, {
        enter(node, parent) {
            if (node.range[0] &#x3c;= index &#x26;&#x26; index &#x3c; node.range[1]) {
                result = node;
                resultParent = parent;
            } else {
                this.skip();
            }
        },
        leave(node) {
            if (node === result) {
                this.break();
            }
        }
    });

    return result ? Object.assign({ parent: resultParent }, result) : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.SourceCode.prototype.getText" id="apidoc.element.eslint.SourceCode.prototype.getText">
        function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>getText
        <span class="apidocSignatureSpan">(node, beforeCount, afterCount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getText(node, beforeCount, afterCount) {
    if (node) {
        return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),
            node.range[1] + (afterCount || 0));
    }
    return this.text;


}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return {
        start: Object.assign({}, start),
        end: Object.assign({}, end)
    };
},

/**
* Gets the parenthesized text of a node. This is similar to sourceCode.<span class="apidocCodeKeywordSpan">getText</span>(node),
but it also includes any parentheses
* surrounding the node.
* @param {SourceCode} sourceCode The source code object
* @param {ASTNode} node An expression node
* @returns {string} The text representing the node, with all surrounding parentheses included
*/
getParenthesisedText(sourceCode, node) {
    let leftToken = sourceCode.getFirstToken(node);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.SourceCode.prototype.isSpaceBetweenTokens" id="apidoc.element.eslint.SourceCode.prototype.isSpaceBetweenTokens">
        function <span class="apidocSignatureSpan">eslint.SourceCode.prototype.</span>isSpaceBetweenTokens
        <span class="apidocSignatureSpan">(first, second)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSpaceBetweenTokens(first, second) {
    const text = this.text.slice(first.range[1], second.range[0]);

    return /\s/.test(text.replace(/\/\*.*?\*\//g, &#x22;&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.ast_utils" id="apidoc.module.eslint.ast_utils">module eslint.ast_utils</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.ast_utils.couldBeError" id="apidoc.element.eslint.ast_utils.couldBeError">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>couldBeError
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">couldBeError(node) {
    switch (node.type) {
        case &#x22;Identifier&#x22;:
        case &#x22;CallExpression&#x22;:
        case &#x22;NewExpression&#x22;:
        case &#x22;MemberExpression&#x22;:
        case &#x22;TaggedTemplateExpression&#x22;:
        case &#x22;YieldExpression&#x22;:
        case &#x22;AwaitExpression&#x22;:
            return true; // possibly an error object.

        case &#x22;AssignmentExpression&#x22;:
            return module.exports.couldBeError(node.right);

        case &#x22;SequenceExpression&#x22;: {
            const exprs = node.expressions;

            return exprs.length !== 0 &#x26;&#x26; module.exports.couldBeError(exprs[exprs.length - 1]);
        }

        case &#x22;LogicalExpression&#x22;:
            return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);

        case &#x22;ConditionalExpression&#x22;:
            return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);

        default:
            return false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x22;MemberExpression&#x22;:
case &#x22;TaggedTemplateExpression&#x22;:
case &#x22;YieldExpression&#x22;:
case &#x22;AwaitExpression&#x22;:
    return true; // possibly an error object.

case &#x22;AssignmentExpression&#x22;:
    return module.exports.<span class="apidocCodeKeywordSpan">couldBeError</span>(node.right);

case &#x22;SequenceExpression&#x22;: {
    const exprs = node.expressions;

    return exprs.length !== 0 &#x26;&#x26; module.exports.couldBeError(exprs[exprs.length - 1]);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.createGlobalLinebreakMatcher" id="apidoc.element.eslint.ast_utils.createGlobalLinebreakMatcher">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>createGlobalLinebreakMatcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createGlobalLinebreakMatcher() {
    return new RegExp(LINEBREAK_MATCHER.source, &#x22;g&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.getDirectivePrologue" id="apidoc.element.eslint.ast_utils.getDirectivePrologue">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getDirectivePrologue
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDirectivePrologue(node) {
    const directives = [];

    // Directive prologues only occur at the top of files or functions.
    if (
        node.type === &#x22;Program&#x22; ||
        node.type === &#x22;FunctionDeclaration&#x22; ||
        node.type === &#x22;FunctionExpression&#x22; ||

        // Do not check arrow functions with implicit return.
        // `() =&#x3e; &#x22;use strict&#x22;;` returns the string `&#x22;use strict&#x22;`.
        (node.type === &#x22;ArrowFunctionExpression&#x22; &#x26;&#x26; node.body.type === &#x22;BlockStatement&#x22;)
    ) {
        const statements = node.type === &#x22;Program&#x22; ? node.body : node.body.body;

        for (const statement of statements) {
            if (
                statement.type === &#x22;ExpressionStatement&#x22; &#x26;&#x26;
                statement.expression.type === &#x22;Literal&#x22;
            ) {
                directives.push(statement);
            } else {
                break;
            }
        }
    }

    return directives;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.getFunctionHeadLoc" id="apidoc.element.eslint.ast_utils.getFunctionHeadLoc">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getFunctionHeadLoc
        <span class="apidocSignatureSpan">(node, sourceCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFunctionHeadLoc(node, sourceCode) {
    const parent = node.parent;
    let start = null;
    let end = null;

    if (node.type === &#x22;ArrowFunctionExpression&#x22;) {
        const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);

        start = arrowToken.loc.start;
        end = arrowToken.loc.end;
    } else if (parent.type === &#x22;Property&#x22; || parent.type === &#x22;MethodDefinition&#x22;) {
        start = parent.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
    } else {
        start = node.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
    }

    return {
        start: Object.assign({}, start),
        end: Object.assign({}, end)
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.getFunctionNameWithKind" id="apidoc.element.eslint.ast_utils.getFunctionNameWithKind">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getFunctionNameWithKind
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFunctionNameWithKind(node) {
    const parent = node.parent;
    const tokens = [];

    if (parent.type === &#x22;MethodDefinition&#x22; &#x26;&#x26; parent.static) {
        tokens.push(&#x22;static&#x22;);
    }
    if (node.async) {
        tokens.push(&#x22;async&#x22;);
    }
    if (node.generator) {
        tokens.push(&#x22;generator&#x22;);
    }

    if (node.type === &#x22;ArrowFunctionExpression&#x22;) {
        tokens.push(&#x22;arrow&#x22;, &#x22;function&#x22;);
    } else if (parent.type === &#x22;Property&#x22; || parent.type === &#x22;MethodDefinition&#x22;) {
        if (parent.kind === &#x22;constructor&#x22;) {
            return &#x22;constructor&#x22;;
        } else if (parent.kind === &#x22;get&#x22;) {
            tokens.push(&#x22;getter&#x22;);
        } else if (parent.kind === &#x22;set&#x22;) {
            tokens.push(&#x22;setter&#x22;);
        } else {
            tokens.push(&#x22;method&#x22;);
        }
    } else {
        tokens.push(&#x22;function&#x22;);
    }

    if (node.id) {
        tokens.push(`&#x27;${node.id.name}&#x27;`);
    } else {
        const name = module.exports.getStaticPropertyName(parent);

        if (name) {
            tokens.push(`&#x27;${name}&#x27;`);
        }
    }

    return tokens.join(&#x22; &#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.getLabel" id="apidoc.element.eslint.ast_utils.getLabel">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getLabel
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLabel(node) {
    if (node.parent.type === &#x22;LabeledStatement&#x22;) {
        return node.parent.label.name;
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.getModifyingReferences" id="apidoc.element.eslint.ast_utils.getModifyingReferences">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getModifyingReferences
        <span class="apidocSignatureSpan">(references)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModifyingReferences(references) {
    return references.filter(isModifyingReference);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.getParenthesisedText" id="apidoc.element.eslint.ast_utils.getParenthesisedText">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getParenthesisedText
        <span class="apidocSignatureSpan">(sourceCode, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParenthesisedText(sourceCode, node) {
    let leftToken = sourceCode.getFirstToken(node);
    let rightToken = sourceCode.getLastToken(node);

    while (
        sourceCode.getTokenBefore(leftToken) &#x26;&#x26;
        sourceCode.getTokenBefore(leftToken).type === &#x22;Punctuator&#x22; &#x26;&#x26;
        sourceCode.getTokenBefore(leftToken).value === &#x22;(&#x22; &#x26;&#x26;
        sourceCode.getTokenAfter(rightToken) &#x26;&#x26;
        sourceCode.getTokenAfter(rightToken).type === &#x22;Punctuator&#x22; &#x26;&#x26;
        sourceCode.getTokenAfter(rightToken).value === &#x22;)&#x22;
    ) {
        leftToken = sourceCode.getTokenBefore(leftToken);
        rightToken = sourceCode.getTokenAfter(rightToken);
    }

    return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.getPrecedence" id="apidoc.element.eslint.ast_utils.getPrecedence">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getPrecedence
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPrecedence(node) {
    switch (node.type) {
        case &#x22;SequenceExpression&#x22;:
            return 0;

        case &#x22;AssignmentExpression&#x22;:
        case &#x22;ArrowFunctionExpression&#x22;:
        case &#x22;YieldExpression&#x22;:
            return 1;

        case &#x22;ConditionalExpression&#x22;:
            return 3;

        case &#x22;LogicalExpression&#x22;:
            switch (node.operator) {
                case &#x22;||&#x22;:
                    return 4;
                case &#x22;&#x26;&#x26;&#x22;:
                    return 5;

                // no default
            }

<span class="apidocCodeCommentSpan">            /* falls through */
</span>
        case &#x22;BinaryExpression&#x22;:

            switch (node.operator) {
                case &#x22;|&#x22;:
                    return 6;
                case &#x22;^&#x22;:
                    return 7;
                case &#x22;&#x26;&#x22;:
                    return 8;
                case &#x22;==&#x22;:
                case &#x22;!=&#x22;:
                case &#x22;===&#x22;:
                case &#x22;!==&#x22;:
                    return 9;
                case &#x22;&#x3c;&#x22;:
                case &#x22;&#x3c;=&#x22;:
                case &#x22;&#x3e;&#x22;:
                case &#x22;&#x3e;=&#x22;:
                case &#x22;in&#x22;:
                case &#x22;instanceof&#x22;:
                    return 10;
                case &#x22;&#x3c;&#x3c;&#x22;:
                case &#x22;&#x3e;&#x3e;&#x22;:
                case &#x22;&#x3e;&#x3e;&#x3e;&#x22;:
                    return 11;
                case &#x22;+&#x22;:
                case &#x22;-&#x22;:
                    return 12;
                case &#x22;*&#x22;:
                case &#x22;/&#x22;:
                case &#x22;%&#x22;:
                    return 13;
                case &#x22;**&#x22;:
                    return 15;

                // no default
            }

            /* falls through */

        case &#x22;UnaryExpression&#x22;:
        case &#x22;AwaitExpression&#x22;:
            return 16;

        case &#x22;UpdateExpression&#x22;:
            return 17;

        case &#x22;CallExpression&#x22;:

            // IIFE is allowed to have parens in any position (#655)
            if (node.callee.type === &#x22;FunctionExpression&#x22;) {
                return -1;
            }
            return 18;

        case &#x22;NewExpression&#x22;:
            return 19;

        // no default
    }
    return 20;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.getStaticPropertyName" id="apidoc.element.eslint.ast_utils.getStaticPropertyName">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getStaticPropertyName
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getStaticPropertyName(node) {
    let prop;

    switch (node &#x26;&#x26; node.type) {
        case &#x22;Property&#x22;:
        case &#x22;MethodDefinition&#x22;:
            prop = node.key;
            break;

        case &#x22;MemberExpression&#x22;:
            prop = node.property;
            break;

        // no default
    }

    switch (prop &#x26;&#x26; prop.type) {
        case &#x22;Literal&#x22;:
            return String(prop.value);

        case &#x22;TemplateLiteral&#x22;:
            if (prop.expressions.length === 0 &#x26;&#x26; prop.quasis.length === 1) {
                return prop.quasis[0].value.cooked;
            }
            break;

        case &#x22;Identifier&#x22;:
            if (!node.computed) {
                return prop.name;
            }
            break;

        // no default
    }

    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
    tokens.push(&#x22;function&#x22;);
}

if (node.id) {
    tokens.push(`&#x27;${node.id.name}&#x27;`);
} else {
    const name = module.exports.<span class="apidocCodeKeywordSpan">getStaticPropertyName</span>(parent);

    if (name) {
        tokens.push(`&#x27;${name}&#x27;`);
    }
}

return tokens.join(&#x22; &#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.getTrailingStatement" id="apidoc.element.eslint.ast_utils.getTrailingStatement">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getTrailingStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trailingStatement(node) {
    switch (node.type) {
    case &#x27;IfStatement&#x27;:
        if (node.alternate != null) {
            return node.alternate;
        }
        return node.consequent;

    case &#x27;LabeledStatement&#x27;:
    case &#x27;ForStatement&#x27;:
    case &#x27;ForInStatement&#x27;:
    case &#x27;WhileStatement&#x27;:
    case &#x27;WithStatement&#x27;:
        return node.body;
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.getUpperFunction" id="apidoc.element.eslint.ast_utils.getUpperFunction">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getUpperFunction
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getUpperFunction(node) {
    while (node) {
        if (anyFunctionPattern.test(node.type)) {
            return node;
        }
        node = node.parent;
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.getVariableByName" id="apidoc.element.eslint.ast_utils.getVariableByName">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>getVariableByName
        <span class="apidocSignatureSpan">(initScope, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getVariableByName(initScope, name) {
    let scope = initScope;

    while (scope) {
        const variable = scope.set.get(name);

        if (variable) {
            return variable;
        }

        scope = scope.upper;
    }

    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isArrayFromMethod" id="apidoc.element.eslint.ast_utils.isArrayFromMethod">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isArrayFromMethod
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArrayFromMethod(node) {
    return (
        node.type === &#x22;MemberExpression&#x22; &#x26;&#x26;
        node.object.type === &#x22;Identifier&#x22; &#x26;&#x26;
        arrayOrTypedArrayPattern.test(node.object.name) &#x26;&#x26;
        node.property.type === &#x22;Identifier&#x22; &#x26;&#x26;
        node.property.name === &#x22;from&#x22; &#x26;&#x26;
        node.computed === false
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isArrowToken" id="apidoc.element.eslint.ast_utils.isArrowToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isArrowToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArrowToken(token) {
    return token.value === &#x22;=&#x3e;&#x22; &#x26;&#x26; token.type === &#x22;Punctuator&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isBreakableStatement" id="apidoc.element.eslint.ast_utils.isBreakableStatement">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isBreakableStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBreakableStatement(node) {
    return breakableTypePattern.test(node.type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isCallee" id="apidoc.element.eslint.ast_utils.isCallee">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isCallee
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCallee(node) {
    return node.parent.type === &#x22;CallExpression&#x22; &#x26;&#x26; node.parent.callee === node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isClosingBraceToken" id="apidoc.element.eslint.ast_utils.isClosingBraceToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isClosingBraceToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isClosingBraceToken(token) {
    return token.value === &#x22;}&#x22; &#x26;&#x26; token.type === &#x22;Punctuator&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isClosingBracketToken" id="apidoc.element.eslint.ast_utils.isClosingBracketToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isClosingBracketToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isClosingBracketToken(token) {
    return token.value === &#x22;]&#x22; &#x26;&#x26; token.type === &#x22;Punctuator&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isClosingParenToken" id="apidoc.element.eslint.ast_utils.isClosingParenToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isClosingParenToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isClosingParenToken(token) {
    return token.value === &#x22;)&#x22; &#x26;&#x26; token.type === &#x22;Punctuator&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isColonToken" id="apidoc.element.eslint.ast_utils.isColonToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isColonToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isColonToken(token) {
    return token.value === &#x22;:&#x22; &#x26;&#x26; token.type === &#x22;Punctuator&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isCommaToken" id="apidoc.element.eslint.ast_utils.isCommaToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isCommaToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCommaToken(token) {
    return token.value === &#x22;,&#x22; &#x26;&#x26; token.type === &#x22;Punctuator&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isCommentToken" id="apidoc.element.eslint.ast_utils.isCommentToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isCommentToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCommentToken(token) {
    return token.type === &#x22;Line&#x22; || token.type === &#x22;Block&#x22; || token.type === &#x22;Shebang&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isDecimalInteger" id="apidoc.element.eslint.ast_utils.isDecimalInteger">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isDecimalInteger
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDecimalInteger(node) {
    return node.type === &#x22;Literal&#x22; &#x26;&#x26; typeof node.value === &#x22;number&#x22; &#x26;&#x26; /^(0|[1-9]\d*)$/.test(node.raw);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isDefaultThisBinding" id="apidoc.element.eslint.ast_utils.isDefaultThisBinding">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isDefaultThisBinding
        <span class="apidocSignatureSpan">(node, sourceCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDefaultThisBinding(node, sourceCode) {
    if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {
        return false;
    }
    const isAnonymous = node.id === null;

    while (node) {
        const parent = node.parent;

        switch (parent.type) {

<span class="apidocCodeCommentSpan">            /*
             * Looks up the destination.
             * e.g., obj.foo = nativeFoo || function foo() { ... };
             */
</span>            case &#x22;LogicalExpression&#x22;:
            case &#x22;ConditionalExpression&#x22;:
                node = parent;
                break;

            // If the upper function is IIFE, checks the destination of the return value.
            // e.g.
            //   obj.foo = (function() {
            //     // setup...
            //     return function foo() { ... };
            //   })();
            case &#x22;ReturnStatement&#x22;: {
                const func = getUpperFunction(parent);

                if (func === null || !isCallee(func)) {
                    return true;
                }
                node = func.parent;
                break;
            }

            // e.g.
            //   var obj = { foo() { ... } };
            //   var obj = { foo: function() { ... } };
            //   class A { constructor() { ... } }
            //   class A { foo() { ... } }
            //   class A { get foo() { ... } }
            //   class A { set foo() { ... } }
            //   class A { static foo() { ... } }
            case &#x22;Property&#x22;:
            case &#x22;MethodDefinition&#x22;:
                return parent.value !== node;

            // e.g.
            //   obj.foo = function foo() { ... };
            //   Foo = function() { ... };
            //   [obj.foo = function foo() { ... }] = a;
            //   [Foo = function() { ... }] = a;
            case &#x22;AssignmentExpression&#x22;:
            case &#x22;AssignmentPattern&#x22;:
                if (parent.right === node) {
                    if (parent.left.type === &#x22;MemberExpression&#x22;) {
                        return false;
                    }
                    if (isAnonymous &#x26;&#x26;
                        parent.left.type === &#x22;Identifier&#x22; &#x26;&#x26;
                        startsWithUpperCase(parent.left.name)
                    ) {
                        return false;
                    }
                }
                return true;

            // e.g.
            //   var Foo = function() { ... };
            case &#x22;VariableDeclarator&#x22;:
                return !(
                    isAnonymous &#x26;&#x26;
                    parent.init === node &#x26;&#x26;
                    parent.id.type === &#x22;Identifier&#x22; &#x26;&#x26;
                    startsWithUpperCase(parent.id.name)
                );

            // e.g.
            //   var foo = function foo() { ... }.bind(obj);
            //   (function foo() { ... }).call(obj);
            //   (function foo() { ... }).apply(obj, []);
            case &#x22;MemberExpression&#x22;:
                return (
                    parent.object !== node ||
                    parent.property.type !== &#x22;Identifier&#x22; ||
                    !bindOrCallOrApplyPattern.test(parent.property.name) ||
                    !isCallee(parent) ||
                    parent.parent.arguments.length === 0 ||
                    isNullOrUndefined(parent.parent.arguments[0])
                );

            // e.g.
            //   Reflect.apply(function() {}, obj, []);
            //   Array.from([], function() {}, obj);
            //   list.forEach(function() {}, obj);
            case &#x22;CallExpression&#x22;:
                if (isReflectApply(parent.callee)) {
                    return (
                        parent.arguments.length !== 3 ||
                        parent.arguments[0] !== node ||
                        isNullOrUndefined(parent.arguments[1])
                    );
                }
                if (isArrayFromMethod(parent.callee)) {
                    return (
                        parent.arguments.length !== 3 ||
                        parent.arguments[1] !== node ||
                        isNullOrUndefined(parent.arguments[2])
                    );
                } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isDirectiveComment" id="apidoc.element.eslint.ast_utils.isDirectiveComment">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isDirectiveComment
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDirectiveComment(node) {
    const comment = node.value.trim();

    return (
        node.type === &#x22;Line&#x22; &#x26;&#x26; comment.indexOf(&#x22;eslint-&#x22;) === 0 ||
        node.type === &#x22;Block&#x22; &#x26;&#x26; (
            comment.indexOf(&#x22;global &#x22;) === 0 ||
            comment.indexOf(&#x22;eslint &#x22;) === 0 ||
            comment.indexOf(&#x22;eslint-&#x22;) === 0
        )
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isES5Constructor" id="apidoc.element.eslint.ast_utils.isES5Constructor">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isES5Constructor
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isES5Constructor(node) {
    return (node.id &#x26;&#x26; startsWithUpperCase(node.id.name));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isEmptyBlock" id="apidoc.element.eslint.ast_utils.isEmptyBlock">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isEmptyBlock
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmptyBlock(node) {
    return Boolean(node &#x26;&#x26; node.type === &#x22;BlockStatement&#x22; &#x26;&#x26; node.body.length === 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Checks whether the given node is an empty function node or not.
 *
 * @param {ASTNode|null} node - The node to check.
 * @returns {boolean} `true` if the node is an empty function.
 */
isEmptyFunction(node) {
    return isFunction(node) &#x26;&#x26; module.exports.<span class="apidocCodeKeywordSpan">isEmptyBlock</span>(node.body);
},

/**
 * Gets the property name of a given node.
 * The node can be a MemberExpression, a Property, or a MethodDefinition.
 *
 * If the name is dynamic, this returns `null`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isEmptyFunction" id="apidoc.element.eslint.ast_utils.isEmptyFunction">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isEmptyFunction
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmptyFunction(node) {
    return isFunction(node) &#x26;&#x26; module.exports.isEmptyBlock(node.body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isFunction" id="apidoc.element.eslint.ast_utils.isFunction">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isFunction
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunction(node) {
    return Boolean(node &#x26;&#x26; anyFunctionPattern.test(node.type));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isInLoop" id="apidoc.element.eslint.ast_utils.isInLoop">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isInLoop
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInLoop(node) {
    while (node &#x26;&#x26; !isFunction(node)) {
        if (isLoop(node)) {
            return true;
        }

        node = node.parent;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isKeywordToken" id="apidoc.element.eslint.ast_utils.isKeywordToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isKeywordToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isKeywordToken(token) {
    return token.type === &#x22;Keyword&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isLoop" id="apidoc.element.eslint.ast_utils.isLoop">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isLoop
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLoop(node) {
    return Boolean(node &#x26;&#x26; anyLoopPattern.test(node.type));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isNotClosingBraceToken" id="apidoc.element.eslint.ast_utils.isNotClosingBraceToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotClosingBraceToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token =&#x3e; !f(token)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isNotClosingBracketToken" id="apidoc.element.eslint.ast_utils.isNotClosingBracketToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotClosingBracketToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token =&#x3e; !f(token)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isNotClosingParenToken" id="apidoc.element.eslint.ast_utils.isNotClosingParenToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotClosingParenToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token =&#x3e; !f(token)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isNotColonToken" id="apidoc.element.eslint.ast_utils.isNotColonToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotColonToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token =&#x3e; !f(token)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isNotCommaToken" id="apidoc.element.eslint.ast_utils.isNotCommaToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotCommaToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token =&#x3e; !f(token)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isNotOpeningBraceToken" id="apidoc.element.eslint.ast_utils.isNotOpeningBraceToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotOpeningBraceToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token =&#x3e; !f(token)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isNotOpeningBracketToken" id="apidoc.element.eslint.ast_utils.isNotOpeningBracketToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotOpeningBracketToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token =&#x3e; !f(token)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isNotOpeningParenToken" id="apidoc.element.eslint.ast_utils.isNotOpeningParenToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotOpeningParenToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token =&#x3e; !f(token)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isNotSemicolonToken" id="apidoc.element.eslint.ast_utils.isNotSemicolonToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNotSemicolonToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token =&#x3e; !f(token)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isNullLiteral" id="apidoc.element.eslint.ast_utils.isNullLiteral">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNullLiteral
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNullLiteral(node) {

<span class="apidocCodeCommentSpan">    /*
     * Checking `node.value === null` does not guarantee that a literal is a null literal.
     * When parsing values that cannot be represented in the current environment (e.g. unicode
     * regexes in Node 4), `node.value` is set to `null` because it wouldn&#x27;t be possible to
     * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check
     * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020
     */
</span>    return node.type === &#x22;Literal&#x22; &#x26;&#x26; node.value === null &#x26;&#x26; !node.regex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Checks whether or not a node is `null` or `undefined`.
* @param {ASTNode} node - A node to check.
* @returns {boolean} Whether or not the node is a `null` or `undefined`.
* @public
*/
function isNullOrUndefined(node) {
   return (
       module.exports.<span class="apidocCodeKeywordSpan">isNullLiteral</span>(node) ||
       (node.type === &#x22;Identifier&#x22; &#x26;&#x26; node.name === &#x22;undefined&#x22;) ||
       (node.type === &#x22;UnaryExpression&#x22; &#x26;&#x26; node.operator === &#x22;void&#x22;)
   );
}

/**
* Checks whether or not a node is callee.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isNullOrUndefined" id="apidoc.element.eslint.ast_utils.isNullOrUndefined">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isNullOrUndefined
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNullOrUndefined(node) {
    return (
        module.exports.isNullLiteral(node) ||
        (node.type === &#x22;Identifier&#x22; &#x26;&#x26; node.name === &#x22;undefined&#x22;) ||
        (node.type === &#x22;UnaryExpression&#x22; &#x26;&#x26; node.operator === &#x22;void&#x22;)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isOpeningBraceToken" id="apidoc.element.eslint.ast_utils.isOpeningBraceToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isOpeningBraceToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOpeningBraceToken(token) {
    return token.value === &#x22;{&#x22; &#x26;&#x26; token.type === &#x22;Punctuator&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isOpeningBracketToken" id="apidoc.element.eslint.ast_utils.isOpeningBracketToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isOpeningBracketToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOpeningBracketToken(token) {
    return token.value === &#x22;[&#x22; &#x26;&#x26; token.type === &#x22;Punctuator&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isOpeningParenToken" id="apidoc.element.eslint.ast_utils.isOpeningParenToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isOpeningParenToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOpeningParenToken(token) {
    return token.value === &#x22;(&#x22; &#x26;&#x26; token.type === &#x22;Punctuator&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isParenthesised" id="apidoc.element.eslint.ast_utils.isParenthesised">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isParenthesised
        <span class="apidocSignatureSpan">(sourceCode, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isParenthesised(sourceCode, node) {
    const previousToken = sourceCode.getTokenBefore(node),
        nextToken = sourceCode.getTokenAfter(node);

    return Boolean(previousToken &#x26;&#x26; nextToken) &#x26;&#x26;
        previousToken.value === &#x22;(&#x22; &#x26;&#x26; previousToken.range[1] &#x3c;= node.range[0] &#x26;&#x26;
        nextToken.value === &#x22;)&#x22; &#x26;&#x26; nextToken.range[0] &#x3e;= node.range[1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isSemicolonToken" id="apidoc.element.eslint.ast_utils.isSemicolonToken">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isSemicolonToken
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSemicolonToken(token) {
    return token.value === &#x22;;&#x22; &#x26;&#x26; token.type === &#x22;Punctuator&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isStringLiteral" id="apidoc.element.eslint.ast_utils.isStringLiteral">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isStringLiteral
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStringLiteral(node) {
    return (
        (node.type === &#x22;Literal&#x22; &#x26;&#x26; typeof node.value === &#x22;string&#x22;) ||
        node.type === &#x22;TemplateLiteral&#x22;
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isSurroundedBy" id="apidoc.element.eslint.ast_utils.isSurroundedBy">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isSurroundedBy
        <span class="apidocSignatureSpan">(val, character)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSurroundedBy(val, character) {
    return val[0] === character &#x26;&#x26; val[val.length - 1] === character;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.ast_utils.isTokenOnSameLine" id="apidoc.element.eslint.ast_utils.isTokenOnSameLine">
        function <span class="apidocSignatureSpan">eslint.ast_utils.</span>isTokenOnSameLine
        <span class="apidocSignatureSpan">(left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTokenOnSameLine(left, right) {
    return left.loc.end.line === right.loc.start.line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.linter" id="apidoc.module.eslint.linter">module eslint.linter</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.linter.defaults" id="apidoc.element.eslint.linter.defaults">
        function <span class="apidocSignatureSpan">eslint.linter.</span>defaults
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function () {
    return require(&#x22;../conf/eslint-recommended&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.defineRule" id="apidoc.element.eslint.linter.defineRule">
        function <span class="apidocSignatureSpan">eslint.linter.</span>defineRule
        <span class="apidocSignatureSpan">(ruleId, ruleModule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineRule = function (ruleId, ruleModule) {
    rules.define(ruleId, ruleModule);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.defineRules" id="apidoc.element.eslint.linter.defineRules">
        function <span class="apidocSignatureSpan">eslint.linter.</span>defineRules
        <span class="apidocSignatureSpan">(rulesToDefine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineRules = function (rulesToDefine) {
    Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId =&#x3e; {
        defineRule(ruleId, rulesToDefine[ruleId]);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getAllComments" id="apidoc.element.eslint.linter.getAllComments">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getAllComments
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllComments = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getAncestors" id="apidoc.element.eslint.linter.getAncestors">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getAncestors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAncestors = function () {
    return traverser.parents();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getComments" id="apidoc.element.eslint.linter.getComments">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getComments
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComments = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       return true;
   }

   // Checks `@this` in its leading comments for callbacks,
   // because callbacks don&#x27;t have its JSDoc comment.
   // e.g.
   //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });
   return sourceCode.<span class="apidocCodeKeywordSpan">getComments</span>(node).leading.some(comment =&#x3e; thisTagPattern.test
(comment.value));
}

/**
* Determines if a node is surrounded by parentheses.
* @param {SourceCode} sourceCode The ESLint source code object
* @param {ASTNode} node The node to be checked.
* @returns {boolean} True if the node is parenthesised.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getDeclaredVariables" id="apidoc.element.eslint.linter.getDeclaredVariables">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getDeclaredVariables
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDeclaredVariables = function (node) {
    return (scopeManager &#x26;&#x26; scopeManager.getDeclaredVariables(node)) || [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getFilename" id="apidoc.element.eslint.linter.getFilename">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getFilename
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFilename = function () {
    if (typeof currentFilename === &#x22;string&#x22;) {
        return currentFilename;
    }
    return &#x22;&#x3c;input&#x3e;&#x22;;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getFirstToken" id="apidoc.element.eslint.linter.getFirstToken">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getFirstToken
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirstToken = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {ASTNode} node - The function node to get.
* @param {SourceCode} sourceCode - The source code object to get tokens.
* @returns {Token} `(` token.
*/
function getOpeningParenOfParams(node, sourceCode) {
   return node.id
       ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)
       : sourceCode.<span class="apidocCodeKeywordSpan">getFirstToken</span>(node, isOpeningParenToken);
}

/**
* Creates a version of the LINEBREAK_MATCHER regex with the global flag.
* Global regexes are mutable, so this needs to be a function instead of a constant.
* @returns {RegExp} A global regular expression that matches line terminators
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getFirstTokens" id="apidoc.element.eslint.linter.getFirstTokens">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getFirstTokens
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirstTokens = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getJSDocComment" id="apidoc.element.eslint.linter.getJSDocComment">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getJSDocComment
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJSDocComment = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Checks whether or not a node has a `@this` tag in its comments.
 * @param {ASTNode} node - A node to check.
 * @param {SourceCode} sourceCode - A SourceCode instance to get comments.
 * @returns {boolean} Whether or not the node has a `@this` tag in its comments.
 */
function hasJSDocThisTag(node, sourceCode) {
const jsdocComment = sourceCode.<span class="apidocCodeKeywordSpan">getJSDocComment</span>(node);

if (jsdocComment &#x26;&#x26; thisTagPattern.test(jsdocComment.value)) {
    return true;
}

// Checks `@this` in its leading comments for callbacks,
// because callbacks don&#x27;t have its JSDoc comment.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getLastToken" id="apidoc.element.eslint.linter.getLastToken">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getLastToken
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastToken = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    * surrounding the node.
    * @param {SourceCode} sourceCode The source code object
    * @param {ASTNode} node An expression node
    * @returns {string} The text representing the node, with all surrounding parentheses included
    */
    getParenthesisedText(sourceCode, node) {
let leftToken = sourceCode.getFirstToken(node);
let rightToken = sourceCode.<span class="apidocCodeKeywordSpan">getLastToken</span>(node);

while (
    sourceCode.getTokenBefore(leftToken) &#x26;&#x26;
    sourceCode.getTokenBefore(leftToken).type === &#x22;Punctuator&#x22; &#x26;&#x26;
    sourceCode.getTokenBefore(leftToken).value === &#x22;(&#x22; &#x26;&#x26;
    sourceCode.getTokenAfter(rightToken) &#x26;&#x26;
    sourceCode.getTokenAfter(rightToken).type === &#x22;Punctuator&#x22; &#x26;&#x26;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getLastTokens" id="apidoc.element.eslint.linter.getLastTokens">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getLastTokens
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastTokens = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getNodeByRangeIndex" id="apidoc.element.eslint.linter.getNodeByRangeIndex">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getNodeByRangeIndex
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodeByRangeIndex = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getRules" id="apidoc.element.eslint.linter.getRules">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRules = function () {
    return rules.getAllLoadedRules();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getScope" id="apidoc.element.eslint.linter.getScope">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getScope = function () {
    const parents = traverser.parents();

    // Don&#x27;t do this for Program nodes - they have no parents
    if (parents.length) {

        // if current node introduces a scope, add it to the list
        const current = traverser.current();

        if (currentConfig.parserOptions.ecmaVersion &#x3e;= 6) {
            if ([&#x22;BlockStatement&#x22;, &#x22;SwitchStatement&#x22;, &#x22;CatchClause&#x22;, &#x22;FunctionDeclaration&#x22;, &#x22;FunctionExpression&#x22;, &#x22;ArrowFunctionExpression
&#x22;].indexOf(current.type) &#x3e;= 0) {
                parents.push(current);
            }
        } else {
            if ([&#x22;FunctionDeclaration&#x22;, &#x22;FunctionExpression&#x22;, &#x22;ArrowFunctionExpression&#x22;].indexOf(current.type) &#x3e;= 0) {
                parents.push(current);
            }
        }

        // Ascend the current node&#x27;s parents
        for (let i = parents.length - 1; i &#x3e;= 0; --i) {

            // Get the innermost scope
            const scope = scopeManager.acquire(parents[i], true);

            if (scope) {
                if (scope.type === &#x22;function-expression-name&#x22;) {
                    return scope.childScopes[0];
                }
                return scope;

            }

        }

    }

    return currentScopes[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getSource" id="apidoc.element.eslint.linter.getSource">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getSource
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSource = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getSourceCode" id="apidoc.element.eslint.linter.getSourceCode">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getSourceCode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceCode = function () {
    return sourceCode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.eslint = eslint;
    this.severity = severity;

    Object.freeze(this);
}

/**
 * Passthrough to eslint.<span class="apidocCodeKeywordSpan">getSourceCode</span>().
 * @returns {SourceCode} The SourceCode object for the code.
 */
getSourceCode() {
    return this.eslint.getSourceCode();
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getSourceLines" id="apidoc.element.eslint.linter.getSourceLines">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getSourceLines
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceLines = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getTokenAfter" id="apidoc.element.eslint.linter.getTokenAfter">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getTokenAfter
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenAfter = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {SourceCode} sourceCode The ESLint source code object
 * @param {ASTNode} node The node to be checked.
 * @returns {boolean} True if the node is parenthesised.
 * @private
 */
function isParenthesised(sourceCode, node) {
    const previousToken = sourceCode.getTokenBefore(node),
        nextToken = sourceCode.<span class="apidocCodeKeywordSpan">getTokenAfter</span>(node);

    return Boolean(previousToken &#x26;&#x26; nextToken) &#x26;&#x26;
        previousToken.value === &#x22;(&#x22; &#x26;&#x26; previousToken.range[1] &#x3c;= node.range[0] &#x26;&#x26;
        nextToken.value === &#x22;)&#x22; &#x26;&#x26; nextToken.range[0] &#x3e;= node.range[1];
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getTokenBefore" id="apidoc.element.eslint.linter.getTokenBefore">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getTokenBefore
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenBefore = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Determines if a node is surrounded by parentheses.
 * @param {SourceCode} sourceCode The ESLint source code object
 * @param {ASTNode} node The node to be checked.
 * @returns {boolean} True if the node is parenthesised.
 * @private
 */
function isParenthesised(sourceCode, node) {
    const previousToken = sourceCode.<span class="apidocCodeKeywordSpan">getTokenBefore</span>(node),
        nextToken = sourceCode.getTokenAfter(node);

    return Boolean(previousToken &#x26;&#x26; nextToken) &#x26;&#x26;
        previousToken.value === &#x22;(&#x22; &#x26;&#x26; previousToken.range[1] &#x3c;= node.range[0] &#x26;&#x26;
        nextToken.value === &#x22;)&#x22; &#x26;&#x26; nextToken.range[0] &#x3e;= node.range[1];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getTokenByRangeStart" id="apidoc.element.eslint.linter.getTokenByRangeStart">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getTokenByRangeStart
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenByRangeStart = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getTokens" id="apidoc.element.eslint.linter.getTokens">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getTokens
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokens = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getTokensAfter" id="apidoc.element.eslint.linter.getTokensAfter">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getTokensAfter
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokensAfter = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getTokensBefore" id="apidoc.element.eslint.linter.getTokensBefore">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getTokensBefore
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokensBefore = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.getTokensBetween" id="apidoc.element.eslint.linter.getTokensBetween">
        function <span class="apidocSignatureSpan">eslint.linter.</span>getTokensBetween
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokensBetween = function (a, b, c, d, e) {
    if (sourceCode) {
        return sourceCode[exMethodName](a, b, c, d, e);
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.markVariableAsUsed" id="apidoc.element.eslint.linter.markVariableAsUsed">
        function <span class="apidocSignatureSpan">eslint.linter.</span>markVariableAsUsed
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">markVariableAsUsed = function (name) {
    const hasGlobalReturn = currentConfig.parserOptions.ecmaFeatures &#x26;&#x26; currentConfig.parserOptions.ecmaFeatures.globalReturn,
        specialScope = hasGlobalReturn || currentConfig.parserOptions.sourceType === &#x22;module&#x22;;
    let scope = this.getScope(),
        i,
        len;

    // Special Node.js scope means we need to start one level deeper
    if (scope.type === &#x22;global&#x22; &#x26;&#x26; specialScope) {
        scope = scope.childScopes[0];
    }

    do {
        const variables = scope.variables;

        for (i = 0, len = variables.length; i &#x3c; len; i++) {
            if (variables[i].name === name) {
                variables[i].eslintUsed = true;
                return true;
            }
        }
    } while ((scope = scope.upper));

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.report" id="apidoc.element.eslint.linter.report">
        function <span class="apidocSignatureSpan">eslint.linter.</span>report
        <span class="apidocSignatureSpan">(ruleId, severity, node, location, message, opts, fix, meta)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">report = function (ruleId, severity, node, location, message, opts, fix, meta) {
    if (node) {
        assert.strictEqual(typeof node, &#x22;object&#x22;, &#x22;Node must be an object&#x22;);
    }

    if (typeof location === &#x22;string&#x22;) {
        assert.ok(node, &#x22;Node must be provided when reporting error if location is not provided&#x22;);

        meta = fix;
        fix = opts;
        opts = message;
        message = location;
        location = node.loc.start;
    }

    // Store end location.
    const endLocation = location.end;

    location = location.start || location;

    if (isDisabledByReportingConfig(reportingConfig, ruleId, location)) {
        return;
    }

    if (opts) {
        message = message.replace(/\{\{\s*([^{}]+?)\s*\}\}/g, (fullMatch, term) =&#x3e; {
            if (term in opts) {
                return opts[term];
            }

            // Preserve old behavior: If parameter name not provided, don&#x27;t replace it.
            return fullMatch;
        });
    }

    const problem = {
        ruleId,
        severity,
        message,
        line: location.line,
        column: location.column + 1,   // switch to 1-base instead of 0-base
        nodeType: node &#x26;&#x26; node.type,
        source: sourceCode.lines[location.line - 1] || &#x22;&#x22;
    };

    // Define endLine and endColumn if exists.
    if (endLocation) {
        problem.endLine = endLocation.line;
        problem.endColumn = endLocation.column + 1;   // switch to 1-base instead of 0-base
    }

    // ensure there&#x27;s range and text properties, otherwise it&#x27;s not a valid fix
    if (fix &#x26;&#x26; Array.isArray(fix.range) &#x26;&#x26; (typeof fix.text === &#x22;string&#x22;)) {

        // If rule uses fix, has metadata, but has no metadata.fixable, we should throw
        if (meta &#x26;&#x26; !meta.fixable) {
            throw new Error(&#x22;Fixable rules should export a `meta.fixable` property.&#x22;);
        }

        problem.fix = fix;
    }

    messages.push(problem);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {SourceCode} The SourceCode object for the code.
 */
getSourceCode() {
    return this.eslint.getSourceCode();
}

/**
 * Passthrough to eslint.<span class="apidocCodeKeywordSpan">report</span>() that automatically assigns the rule ID and severity
.
 * @param {ASTNode|MessageDescriptor} nodeOrDescriptor The AST node related to the message or a message
 *      descriptor.
 * @param {Object=} location The location of the error.
 * @param {string} message The message to display to the user.
 * @param {Object} opts Optional template data which produces a formatted message
 *     with symbols being replaced by this object&#x27;s values.
 * @returns {void}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.reset" id="apidoc.element.eslint.linter.reset">
        function <span class="apidocSignatureSpan">eslint.linter.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
    this.removeAllListeners();
    messages = [];
    currentConfig = null;
    currentScopes = null;
    scopeManager = null;
    traverser = null;
    reportingConfig = [];
    sourceCode = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.linter.verify" id="apidoc.element.eslint.linter.verify">
        function <span class="apidocSignatureSpan">eslint.linter.</span>verify
        <span class="apidocSignatureSpan">(textOrSourceCode, config, filenameOrOptions, saveState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (textOrSourceCode, config, filenameOrOptions, saveState) {
    const text = (typeof textOrSourceCode === &#x22;string&#x22;) ? textOrSourceCode : null;
    let ast,
        parseResult,
        shebang,
        allowInlineConfig;

    // evaluate arguments
    if (typeof filenameOrOptions === &#x22;object&#x22;) {
        currentFilename = filenameOrOptions.filename;
        allowInlineConfig = filenameOrOptions.allowInlineConfig;
        saveState = filenameOrOptions.saveState;
    } else {
        currentFilename = filenameOrOptions;
    }

    if (!saveState) {
        this.reset();
    }

    // search and apply &#x22;eslint-env *&#x22;.
    const envInFile = findEslintEnv(text || textOrSourceCode.text);

    config = Object.assign({}, config);

    if (envInFile) {
        if (config.env) {
            config.env = Object.assign({}, config.env, envInFile);
        } else {
            config.env = envInFile;
        }
    }

    // process initial config to make it safe to extend
    config = prepareConfig(config);

    // only do this for text
    if (text !== null) {

        // there&#x27;s no input, just exit here
        if (text.trim().length === 0) {
            sourceCode = new SourceCode(text, blankScriptAST);
            return messages;
        }

        parseResult = parse(
            stripUnicodeBOM(text).replace(/^#!([^\r\n]+)/, (match, captured) =&#x3e; {
                shebang = captured;
                return `//${captured}`;
            }),
            config,
            currentFilename
        );

        // if this result is from a parseForESLint() method, normalize
        if (parseResult &#x26;&#x26; parseResult.ast) {
            ast = parseResult.ast;
        } else {
            ast = parseResult;
            parseResult = null;
        }

        if (ast) {
            sourceCode = new SourceCode(text, ast);
        }

    } else {
        sourceCode = textOrSourceCode;
        ast = sourceCode.ast;
    }

    // if espree failed to parse the file, there&#x27;s no sense in setting up rules
    if (ast) {

        // parse global comments and modify config
        if (allowInlineConfig !== false) {
            config = modifyConfigsFromComments(currentFilename, ast, config, reportingConfig, messages);
        }

        // ensure that severities are normalized in the config
        ConfigOps.normalize(config);

        // enable appropriate rules
        Object.keys(config.rules).filter(key =&#x3e; getRuleSeverity(config.rules[key]) &#x3e; 0).forEach(key =&#x3e; {
            let ruleCreator;

            ruleCreator = rules.get(key);

            if (!ruleCreator) {
                const replacementMsg = getRuleReplacementMessage(key);

                if (replacementMsg) {
                    ruleCreator = createStubRule(replacementMsg);
                } else {
                    ruleCreator = createStubRule(`Definition for rule &#x27;${key}&#x27; was not found`);
                }
                rules.define(key, ruleCreator);
            }

            const severity = getRuleSeverity(config.rules[key]);
            const options = getRuleOptions(config.rules[key]);

            try {
                const ruleContext = new RuleContext(
                    key, api, severity, options,
                    config.settings, config.parserOptions, config.parser,
                    ruleCreator.meta,
                    (parseResult &#x26;&#x26; parseResult.services ? parseResult.services : {})
                );

                const rule = ruleCreator.create ? ruleCreator.create(ruleContext)
                    : ruleCreator(ruleContext);

                // add all the selectors from the rule as listeners
                Object.keys(rule).forEach(selector =&#x3e; {
                    api.on(selector, timing.enabled
                        ? timing.time(key, rule[selector])
                        : rule[selector]
                    );
                });
            } catch (ex) {
                ex.message = `Error while loading rule &#x27;${key}&#x27;: ${ex.message}`;
                throw ex;
            }
        });

        // save config so rules can access as necess ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.logging" id="apidoc.module.eslint.logging">module eslint.logging</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.logging.error" id="apidoc.element.eslint.logging.error">
        function <span class="apidocSignatureSpan">eslint.logging.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error() {
    console.error.apply(console, Array.prototype.slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.logging.info" id="apidoc.element.eslint.logging.info">
        function <span class="apidocSignatureSpan">eslint.logging.</span>info
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">info() {
    console.log.apply(console, Array.prototype.slice.call(arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.options" id="apidoc.module.eslint.options">module eslint.options</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.options.generateHelp" id="apidoc.element.eslint.options.generateHelp">
        function <span class="apidocSignatureSpan">eslint.options.</span>generateHelp
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateHelp = function (arg$){
  var ref$, showHidden, interpolate, maxWidth, output, out, data, optionCount, totalPreLen, preLens, i$, len$, item, that, pre,
descParts, desc, preLen, sortedPreLens, maxPreLen, preLenMean, x, padAmount, descSepLen, fullWrapCount, partialWrapCount, descLen
, totalLen, initialSpace, wrapAllFull, i, wrap;
  ref$ = arg$ != null
    ? arg$
    : {}, showHidden = ref$.showHidden, interpolate = ref$.interpolate;
  maxWidth = stdout != null &#x26;&#x26; stdout.isTTY ? stdout.columns - 1 : null;
  output = [];
  out = function(it){
    return output.push(it != null ? it : &#x27;&#x27;);
  };
  if (prepend) {
    out(interpolate ? interp(prepend, interpolate) : prepend);
    out();
  }
  data = [];
  optionCount = 0;
  totalPreLen = 0;
  preLens = [];
  for (i$ = 0, len$ = (ref$ = options).length; i$ &#x3c; len$; ++i$) {
    item = ref$[i$];
    if (showHidden || !item.hidden) {
      if (that = item.heading) {
        data.push({
          type: &#x27;heading&#x27;,
          value: that
        });
      } else {
        pre = getPreText(item, helpStyle, maxWidth);
        descParts = [];
        if ((that = item.description) != null) {
          descParts.push(that);
        }
        if (that = item[&#x27;enum&#x27;]) {
          descParts.push(&#x22;either: &#x22; + naturalJoin(that));
        }
        if (item[&#x27;default&#x27;] &#x26;&#x26; !item.negateName) {
          descParts.push(&#x22;default: &#x22; + item[&#x27;default&#x27;]);
        }
        desc = descParts.join(&#x27; - &#x27;);
        data.push({
          type: &#x27;option&#x27;,
          pre: pre,
          desc: desc,
          descLen: desc.length
        });
        preLen = pre.length;
        optionCount++;
        totalPreLen += preLen;
        preLens.push(preLen);
      }
    }
  }
  sortedPreLens = sort(preLens);
  maxPreLen = sortedPreLens[sortedPreLens.length - 1];
  preLenMean = initialIndent + totalPreLen / optionCount;
  x = optionCount &#x3e; 2 ? min(preLenMean * maxPadFactor, maxPreLen) : maxPreLen;
  for (i$ = sortedPreLens.length - 1; i$ &#x3e;= 0; --i$) {
    preLen = sortedPreLens[i$];
    if (preLen &#x3c;= x) {
      padAmount = preLen;
      break;
    }
  }
  descSepLen = descriptionSeparator.length;
  if (maxWidth != null) {
    fullWrapCount = 0;
    partialWrapCount = 0;
    for (i$ = 0, len$ = data.length; i$ &#x3c; len$; ++i$) {
      item = data[i$];
      if (item.type === &#x27;option&#x27;) {
        pre = item.pre, desc = item.desc, descLen = item.descLen;
        if (descLen === 0) {
          item.wrap = &#x27;none&#x27;;
        } else {
          preLen = max(padAmount, pre.length) + initialIndent + descSepLen;
          totalLen = preLen + descLen;
          if (totalLen &#x3e; maxWidth) {
            if (descLen / 2.5 &#x3e; maxWidth - preLen) {
              fullWrapCount++;
              item.wrap = &#x27;full&#x27;;
            } else {
              partialWrapCount++;
              item.wrap = &#x27;partial&#x27;;
            }
          } else {
            item.wrap = &#x27;none&#x27;;
          }
        }
      }
    }
  }
  initialSpace = repeatString$(&#x27; &#x27;, initialIndent);
  wrapAllFull = optionCount &#x3e; 1 &#x26;&#x26; fullWrapCount + partialWrapCount * 0.5 &#x3e; optionCount * 0.5;
  for (i$ = 0, len$ = data.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    item = data[i$];
    if (item.type === &#x27;heading&#x27;) {
      if (i !== 0) {
        out();
      }
      out(item.value + &#x22;:&#x22;);
    } else {
      pre = item.pre, desc = item.desc, descLen = item.descLen, wrap = item.wrap;
      if (maxWidth != null) {
        if (wrapAllFull || wrap === &#x27;full&#x27;) {
          wrap = wordwrap(initialIndent + secondaryIndent, maxWidth);
          out(initialSpace + &#x22;&#x22; + pre + &#x22;\n&#x22; + wrap(desc));
          continue;
        } else if (wrap === &#x27;partial&#x27;) {
          wrap = wordwrap(initialIndent + descSepLen + max(padAmount, pre.length), maxWidth);
          out(initialSpace + &#x22;&#x22; + pad(pre, padAmount) + descriptionSeparator + wrap(desc).replace(/^\s+/, &#x27;&#x27;));
          continue;
        }
      }
      if (descLen === 0) {
        out(initialSpace + &#x22;&#x22; + pre);
      } else {
        out(initialSpace + &#x22;&#x22; + pad(pre, padAmount) + descriptionSeparator + desc);
      }
    }
  }
  if (append) {
    out();
    out(interpola ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.options.generateHelpForOption" id="apidoc.element.eslint.options.generateHelpForOption">
        function <span class="apidocSignatureSpan">eslint.options.</span>generateHelpForOption
        <span class="apidocSignatureSpan">(optionName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateHelpForOption = function (optionName){
  var maxWidth, wrap, option, e, pre, defaultString, restPositionalString, description, fullDescription, that, preDescription, descriptionString
, exampleString, examples, seperator;
  maxWidth = stdout != null &#x26;&#x26; stdout.isTTY ? stdout.columns - 1 : null;
  wrap = maxWidth ? wordwrap(maxWidth) : id;
  try {
    option = getOption(dasherize(optionName));
  } catch (e$) {
    e = e$;
    return e.message;
  }
  pre = getPreText(option, helpStyle);
  defaultString = option[&#x27;default&#x27;] &#x26;&#x26; !option.negateName ? &#x22;\ndefault: &#x22; + option[&#x27;default&#x27;] : &#x27;&#x27;;
  restPositionalString = option.restPositional ? &#x27;Everything after this option is considered a positional argument, even if it looks
 like an option.&#x27; : &#x27;&#x27;;
  description = option.longDescription || option.description &#x26;&#x26; sentencize(option.description);
  fullDescription = description &#x26;&#x26; restPositionalString
    ? description + &#x22; &#x22; + restPositionalString
    : (that = description || restPositionalString) ? that : &#x27;&#x27;;
  preDescription = &#x27;description:&#x27;;
  descriptionString = !fullDescription
    ? &#x27;&#x27;
    : maxWidth &#x26;&#x26; fullDescription.length - 1 - preDescription.length &#x3e; maxWidth
      ? &#x22;\n&#x22; + preDescription + &#x22;\n&#x22; + wrap(fullDescription)
      : &#x22;\n&#x22; + preDescription + &#x22; &#x22; + fullDescription;
  exampleString = (that = option.example) ? (examples = [].concat(that), examples.length &#x3e; 1
    ? &#x22;\nexamples:\n&#x22; + unlines(examples)
    : &#x22;\nexample: &#x22; + examples[0]) : &#x27;&#x27;;
  seperator = defaultString || descriptionString || exampleString ? &#x22;\n&#x22; + repeatString$(&#x27;=&#x27;, pre.length) : &#x27;&#x27;;
  return pre + &#x22;&#x22; + seperator + defaultString + descriptionString + exampleString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.options.parse" id="apidoc.element.eslint.options.parse">
        function <span class="apidocSignatureSpan">eslint.options.</span>parse
        <span class="apidocSignatureSpan">(input, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (input, arg$){
  var slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError
, checkMutuallyExclusive, checkDependency, checkDependencies, checkProp, args, key, value, option, ref$, i$, len$, arg, that, result
, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, valPrime, negated, noedName;
  slice = (arg$ != null
    ? arg$
    : {}).slice;
  obj = {};
  positional = [];
  restPositional = false;
  overrideRequired = false;
  prop = null;
  setValue = function(name, value){
    var opt, val, cra, e, currentType;
    opt = getOption(name);
    if (opt.boolean) {
      val = value;
    } else {
      try {
        cra = opt.concatRepeatedArrays;
        if (cra != null &#x26;&#x26; cra[0] &#x26;&#x26; cra[1].oneValuePerFlag &#x26;&#x26; opt.parsedType.length === 1 &#x26;&#x26; opt.parsedType[0].structure === &#x27;array
&#x27;) {
          val = [parseLevn(opt.parsedType[0].of, value)];
        } else {
          val = parseLevn(opt.parsedType, value);
        }
      } catch (e$) {
        e = e$;
        throw new Error(&#x22;Invalid value for option &#x27;&#x22; + name + &#x22;&#x27; - expected type &#x22; + opt.type + &#x22;, received value: &#x22; + value + &#x22;.&#x22;);
      }
      if (opt[&#x27;enum&#x27;] &#x26;&#x26; !any(function(it){
        return deepIs(it, val);
      }, opt.parsedPossibilities)) {
        throw new Error(&#x22;Option &#x22; + name + &#x22;: &#x27;&#x22; + val + &#x22;&#x27; not one of &#x22; + naturalJoin(opt[&#x27;enum&#x27;]) + &#x22;.&#x22;);
      }
    }
    currentType = toString$.call(obj[name]).slice(8, -1);
    if (obj[name] != null) {
      if (opt.concatRepeatedArrays != null &#x26;&#x26; opt.concatRepeatedArrays[0] &#x26;&#x26; currentType === &#x27;Array&#x27;) {
        obj[name] = obj[name].concat(val);
      } else if (opt.mergeRepeatedObjects &#x26;&#x26; currentType === &#x27;Object&#x27;) {
        import$(obj[name], val);
      } else {
        obj[name] = val;
      }
    } else {
      obj[name] = val;
    }
    if (opt.restPositional) {
      restPositional = true;
    }
    if (opt.overrideRequired) {
      overrideRequired = true;
    }
  };
  setDefaults = function(){
    var name, ref$, value;
    for (name in ref$ = defaults) {
      value = ref$[name];
      if (obj[name] == null) {
        obj[name] = value;
      }
    }
  };
  checkRequired = function(){
    var i$, ref$, len$, name;
    if (overrideRequired) {
      return;
    }
    for (i$ = 0, len$ = (ref$ = required).length; i$ &#x3c; len$; ++i$) {
      name = ref$[i$];
      if (!obj[name]) {
        throw new Error(&#x22;Option &#x22; + nameToRaw(name) + &#x22; is required.&#x22;);
      }
    }
  };
  mutuallyExclusiveError = function(first, second){
    throw new Error(&#x22;The options &#x22; + nameToRaw(first) + &#x22; and &#x22; + nameToRaw(second) + &#x22; are mutually exclusive - you cannot use
them at the same time.&#x22;);
  };
  checkMutuallyExclusive = function(){
    var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;
    rules = libOptions.mutuallyExclusive;
    if (!rules) {
      return;
    }
    for (i$ = 0, len$ = rules.length; i$ &#x3c; len$; ++i$) {
      rule = rules[i$];
      present = null;
      for (j$ = 0, len1$ = rule.length; j$ &#x3c; len1$; ++j$) {
        element = rule[j$];
        if (toString$.call(element).slice(8, -1) === &#x27;Array&#x27;) {
          for (k$ = 0, len2$ = element.length; k$ &#x3c; len2$; ++k$) {
            opt = element[k$];
            if (opt in obj) {
              if (present != null) {
                mutuallyExclusiveError(present, opt);
              } else {
                present = opt;
                break;
              }
            }
          }
        } else {
          if (element in obj) {
            if (present != null) {
              mutuallyExclusiveError(present, element);
            } else {
              present = element;
            }
          }
        }
      }
    }
  };
  checkDependency = function(option){
    var dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;
    dependsOn = option.dependsOn;
    if (!dependsOn || option.dependenciesMet) {
      return true;
    }
    type = dependsOn[0], targetOptionNames = slice$.call(dependsOn, 1);
    for (i$ = 0, len$ = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.options.parseArgv" id="apidoc.element.eslint.options.parseArgv">
        function <span class="apidocSignatureSpan">eslint.options.</span>parseArgv
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseArgv = function (it){
  return parse(it, {
    slice: 2
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.rule_context" id="apidoc.module.eslint.rule_context">module eslint.rule_context</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.rule_context.rule_context" id="apidoc.element.eslint.rule_context.rule_context">
        function <span class="apidocSignatureSpan">eslint.</span>rule_context
        <span class="apidocSignatureSpan">(ruleId, eslint, severity, options, settings, parserOptions, parserPath, meta, parserServices)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class RuleContext {

<span class="apidocCodeCommentSpan">    /**
     * @param {string} ruleId The ID of the rule using this object.
     * @param {eslint} eslint The eslint object.
     * @param {number} severity The configured severity level of the rule.
     * @param {Array} options The configuration information to be added to the rule.
     * @param {Object} settings The configuration settings passed from the config file.
     * @param {Object} parserOptions The parserOptions settings passed from the config file.
     * @param {Object} parserPath The parser setting passed from the config file.
     * @param {Object} meta The metadata of the rule
     * @param {Object} parserServices The parser services for the rule.
     */
</span>    constructor(ruleId, eslint, severity, options, settings, parserOptions, parserPath, meta, parserServices) {

        // public.
        this.id = ruleId;
        this.options = options;
        this.settings = settings;
        this.parserOptions = parserOptions;
        this.parserPath = parserPath;
        this.meta = meta;

        // create a separate copy and freeze it (it&#x27;s not nice to freeze other people&#x27;s objects)
        this.parserServices = Object.freeze(Object.assign({}, parserServices));

        // private.
        this.eslint = eslint;
        this.severity = severity;

        Object.freeze(this);
    }

    /**
     * Passthrough to eslint.getSourceCode().
     * @returns {SourceCode} The SourceCode object for the code.
     */
    getSourceCode() {
        return this.eslint.getSourceCode();
    }

    /**
     * Passthrough to eslint.report() that automatically assigns the rule ID and severity.
     * @param {ASTNode|MessageDescriptor} nodeOrDescriptor The AST node related to the message or a message
     *      descriptor.
     * @param {Object=} location The location of the error.
     * @param {string} message The message to display to the user.
     * @param {Object} opts Optional template data which produces a formatted message
     *     with symbols being replaced by this object&#x27;s values.
     * @returns {void}
     */
    report(nodeOrDescriptor, location, message, opts) {

        // check to see if it&#x27;s a new style call
        if (arguments.length === 1) {
            const descriptor = nodeOrDescriptor;
            let fix = null;

            // if there&#x27;s a fix specified, get it
            if (typeof descriptor.fix === &#x22;function&#x22;) {
                fix = descriptor.fix(ruleFixer);
            }

            this.eslint.report(
                this.id,
                this.severity,
                descriptor.node,
                descriptor.loc || descriptor.node.loc.start,
                descriptor.message,
                descriptor.data,
                fix,
                this.meta
            );

            return;
        }

        // old style call
        this.eslint.report(
            this.id,
            this.severity,
            nodeOrDescriptor,
            location,
            message,
            opts,
            this.meta
        );
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.rule_context.prototype" id="apidoc.module.eslint.rule_context.prototype">module eslint.rule_context.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getAllComments" id="apidoc.element.eslint.rule_context.prototype.getAllComments">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getAllComments
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllComments = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getAncestors" id="apidoc.element.eslint.rule_context.prototype.getAncestors">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getAncestors
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAncestors = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getComments" id="apidoc.element.eslint.rule_context.prototype.getComments">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getComments
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComments = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       return true;
   }

   // Checks `@this` in its leading comments for callbacks,
   // because callbacks don&#x27;t have its JSDoc comment.
   // e.g.
   //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });
   return sourceCode.<span class="apidocCodeKeywordSpan">getComments</span>(node).leading.some(comment =&#x3e; thisTagPattern.test
(comment.value));
}

/**
* Determines if a node is surrounded by parentheses.
* @param {SourceCode} sourceCode The ESLint source code object
* @param {ASTNode} node The node to be checked.
* @returns {boolean} True if the node is parenthesised.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getDeclaredVariables" id="apidoc.element.eslint.rule_context.prototype.getDeclaredVariables">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getDeclaredVariables
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDeclaredVariables = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getFilename" id="apidoc.element.eslint.rule_context.prototype.getFilename">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getFilename
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFilename = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getFirstToken" id="apidoc.element.eslint.rule_context.prototype.getFirstToken">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getFirstToken
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirstToken = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {ASTNode} node - The function node to get.
* @param {SourceCode} sourceCode - The source code object to get tokens.
* @returns {Token} `(` token.
*/
function getOpeningParenOfParams(node, sourceCode) {
   return node.id
       ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)
       : sourceCode.<span class="apidocCodeKeywordSpan">getFirstToken</span>(node, isOpeningParenToken);
}

/**
* Creates a version of the LINEBREAK_MATCHER regex with the global flag.
* Global regexes are mutable, so this needs to be a function instead of a constant.
* @returns {RegExp} A global regular expression that matches line terminators
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getFirstTokens" id="apidoc.element.eslint.rule_context.prototype.getFirstTokens">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getFirstTokens
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFirstTokens = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getJSDocComment" id="apidoc.element.eslint.rule_context.prototype.getJSDocComment">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getJSDocComment
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJSDocComment = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Checks whether or not a node has a `@this` tag in its comments.
 * @param {ASTNode} node - A node to check.
 * @param {SourceCode} sourceCode - A SourceCode instance to get comments.
 * @returns {boolean} Whether or not the node has a `@this` tag in its comments.
 */
function hasJSDocThisTag(node, sourceCode) {
const jsdocComment = sourceCode.<span class="apidocCodeKeywordSpan">getJSDocComment</span>(node);

if (jsdocComment &#x26;&#x26; thisTagPattern.test(jsdocComment.value)) {
    return true;
}

// Checks `@this` in its leading comments for callbacks,
// because callbacks don&#x27;t have its JSDoc comment.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getLastToken" id="apidoc.element.eslint.rule_context.prototype.getLastToken">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getLastToken
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastToken = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    * surrounding the node.
    * @param {SourceCode} sourceCode The source code object
    * @param {ASTNode} node An expression node
    * @returns {string} The text representing the node, with all surrounding parentheses included
    */
    getParenthesisedText(sourceCode, node) {
let leftToken = sourceCode.getFirstToken(node);
let rightToken = sourceCode.<span class="apidocCodeKeywordSpan">getLastToken</span>(node);

while (
    sourceCode.getTokenBefore(leftToken) &#x26;&#x26;
    sourceCode.getTokenBefore(leftToken).type === &#x22;Punctuator&#x22; &#x26;&#x26;
    sourceCode.getTokenBefore(leftToken).value === &#x22;(&#x22; &#x26;&#x26;
    sourceCode.getTokenAfter(rightToken) &#x26;&#x26;
    sourceCode.getTokenAfter(rightToken).type === &#x22;Punctuator&#x22; &#x26;&#x26;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getLastTokens" id="apidoc.element.eslint.rule_context.prototype.getLastTokens">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getLastTokens
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastTokens = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getNodeByRangeIndex" id="apidoc.element.eslint.rule_context.prototype.getNodeByRangeIndex">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getNodeByRangeIndex
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodeByRangeIndex = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getScope" id="apidoc.element.eslint.rule_context.prototype.getScope">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getScope
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getScope = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getSource" id="apidoc.element.eslint.rule_context.prototype.getSource">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getSource
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSource = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getSourceLines" id="apidoc.element.eslint.rule_context.prototype.getSourceLines">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getSourceLines
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSourceLines = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getTokenAfter" id="apidoc.element.eslint.rule_context.prototype.getTokenAfter">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokenAfter
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenAfter = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {SourceCode} sourceCode The ESLint source code object
 * @param {ASTNode} node The node to be checked.
 * @returns {boolean} True if the node is parenthesised.
 * @private
 */
function isParenthesised(sourceCode, node) {
    const previousToken = sourceCode.getTokenBefore(node),
        nextToken = sourceCode.<span class="apidocCodeKeywordSpan">getTokenAfter</span>(node);

    return Boolean(previousToken &#x26;&#x26; nextToken) &#x26;&#x26;
        previousToken.value === &#x22;(&#x22; &#x26;&#x26; previousToken.range[1] &#x3c;= node.range[0] &#x26;&#x26;
        nextToken.value === &#x22;)&#x22; &#x26;&#x26; nextToken.range[0] &#x3e;= node.range[1];
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getTokenBefore" id="apidoc.element.eslint.rule_context.prototype.getTokenBefore">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokenBefore
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenBefore = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Determines if a node is surrounded by parentheses.
 * @param {SourceCode} sourceCode The ESLint source code object
 * @param {ASTNode} node The node to be checked.
 * @returns {boolean} True if the node is parenthesised.
 * @private
 */
function isParenthesised(sourceCode, node) {
    const previousToken = sourceCode.<span class="apidocCodeKeywordSpan">getTokenBefore</span>(node),
        nextToken = sourceCode.getTokenAfter(node);

    return Boolean(previousToken &#x26;&#x26; nextToken) &#x26;&#x26;
        previousToken.value === &#x22;(&#x22; &#x26;&#x26; previousToken.range[1] &#x3c;= node.range[0] &#x26;&#x26;
        nextToken.value === &#x22;)&#x22; &#x26;&#x26; nextToken.range[0] &#x3e;= node.range[1];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getTokenByRangeStart" id="apidoc.element.eslint.rule_context.prototype.getTokenByRangeStart">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokenByRangeStart
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenByRangeStart = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getTokens" id="apidoc.element.eslint.rule_context.prototype.getTokens">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokens
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokens = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getTokensAfter" id="apidoc.element.eslint.rule_context.prototype.getTokensAfter">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokensAfter
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokensAfter = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getTokensBefore" id="apidoc.element.eslint.rule_context.prototype.getTokensBefore">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokensBefore
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokensBefore = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.getTokensBetween" id="apidoc.element.eslint.rule_context.prototype.getTokensBetween">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>getTokensBetween
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokensBetween = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rule_context.prototype.markVariableAsUsed" id="apidoc.element.eslint.rule_context.prototype.markVariableAsUsed">
        function <span class="apidocSignatureSpan">eslint.rule_context.prototype.</span>markVariableAsUsed
        <span class="apidocSignatureSpan">(a, b, c, d, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">markVariableAsUsed = function (a, b, c, d, e) {
    return this.eslint[name](a, b, c, d, e);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.rules" id="apidoc.module.eslint.rules">module eslint.rules</a></h1>


    <h2>
        <a href="#apidoc.element.eslint.rules.define" id="apidoc.element.eslint.rules.define">
        function <span class="apidocSignatureSpan">eslint.rules.</span>define
        <span class="apidocSignatureSpan">(ruleId, ruleModule)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function define(ruleId, ruleModule) {
    rules[ruleId] = ruleModule;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rules.get" id="apidoc.element.eslint.rules.get">
        function <span class="apidocSignatureSpan">eslint.rules.</span>get
        <span class="apidocSignatureSpan">(ruleId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHandler(ruleId) {
    if (typeof rules[ruleId] === &#x22;string&#x22;) {
        return require(rules[ruleId]);
    }
    return rules[ruleId];

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    rules = require(&#x22;../lib/rules&#x22;);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const enabledRules = Object.keys(load()).reduce((result, ruleId) =&#x3e; {
    if (!rules.<span class="apidocCodeKeywordSpan">get</span>(ruleId).meta.deprecated) {
        result[ruleId] = &#x22;error&#x22;;
    }
    return result;
}, {});

//------------------------------------------------------------------------------
// Public Interface
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rules.getAllLoadedRules" id="apidoc.element.eslint.rules.getAllLoadedRules">
        function <span class="apidocSignatureSpan">eslint.rules.</span>getAllLoadedRules
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAllLoadedRules() {
    const allRules = new Map();

    Object.keys(rules).forEach(name =&#x3e; {
        const rule = getHandler(name);

        allRules.set(name, rule);
    });
    return allRules;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rules.importPlugin" id="apidoc.element.eslint.rules.importPlugin">
        function <span class="apidocSignatureSpan">eslint.rules.</span>importPlugin
        <span class="apidocSignatureSpan">(plugin, pluginName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function importPlugin(plugin, pluginName) {
    if (plugin.rules) {
        Object.keys(plugin.rules).forEach(ruleId =&#x3e; {
            const qualifiedRuleId = `${pluginName}/${ruleId}`,
                rule = plugin.rules[ruleId];

            define(qualifiedRuleId, rule);
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rules.load" id="apidoc.element.eslint.rules.load">
        function <span class="apidocSignatureSpan">eslint.rules.</span>load
        <span class="apidocSignatureSpan">(rulesDir, cwd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(rulesDir, cwd) {
    const newRules = loadRules(rulesDir, cwd);

    Object.keys(newRules).forEach(ruleId =&#x3e; {
        define(ruleId, newRules[ruleId]);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            config = configToLoad;

            if (config.extends) {
                config = ConfigFile.applyExtends(config, filePath);
            }
        } else {
            filePath = configToLoad;
            config = ConfigFile.<span class="apidocCodeKeywordSpan">load</span>(filePath);
        }

    }

    return config;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rules.testClear" id="apidoc.element.eslint.rules.testClear">
        function <span class="apidocSignatureSpan">eslint.rules.</span>testClear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testClear() {
    rules = Object.create(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.eslint.rules.testReset" id="apidoc.element.eslint.rules.testReset">
        function <span class="apidocSignatureSpan">eslint.rules.</span>testReset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testReset() {
    testClear();
    load();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.eslint.timing" id="apidoc.module.eslint.timing">module eslint.timing</a></h1>




    <h2>
        <a href="#apidoc.element.eslint.timing.time" id="apidoc.element.eslint.timing.time">
        function <span class="apidocSignatureSpan">eslint.timing.</span>time
        <span class="apidocSignatureSpan">(key, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function time(key, fn) {
    if (typeof data[key] === &#x22;undefined&#x22;) {
        data[key] = 0;
    }

    return function() {
        let t = process.hrtime();

        fn.apply(null, Array.prototype.slice.call(arguments));
        t = process.hrtime(t);
        data[key] += t[0] * 1e3 + t[1] / 1e6;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
